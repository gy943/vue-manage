{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util';\nimport * as zrColor from 'zrender/lib/tool/color';\nimport { linearMap } from '../util/number';\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n\nvar VisualMapping =\n/** @class */\nfunction () {\n  function VisualMapping(option) {\n    var mappingMethod = option.mappingMethod;\n    var visualType = option.type;\n    var thisOption = this.option = zrUtil.clone(option);\n    this.type = visualType;\n    this.mappingMethod = mappingMethod;\n    this._normalizeData = normalizers[mappingMethod];\n    var visualHandler = VisualMapping.visualHandlers[visualType];\n    this.applyVisual = visualHandler.applyVisual;\n    this.getColorMapper = visualHandler.getColorMapper;\n    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];\n\n    if (mappingMethod === 'piecewise') {\n      normalizeVisualRange(thisOption);\n      preprocessForPiecewise(thisOption);\n    } else if (mappingMethod === 'category') {\n      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n      // which need no more preprocess except normalize visual.\n      : normalizeVisualRange(thisOption, true);\n    } else {\n      // mappingMethod === 'linear' or 'fixed'\n      zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n      normalizeVisualRange(thisOption);\n    }\n  }\n\n  VisualMapping.prototype.mapValueToVisual = function (value) {\n    var normalized = this._normalizeData(value);\n\n    return this._normalizedToVisual(normalized, value);\n  };\n\n  VisualMapping.prototype.getNormalizer = function () {\n    return zrUtil.bind(this._normalizeData, this);\n  };\n  /**\n   * List available visual types.\n   *\n   * @public\n   * @return {Array.<string>}\n   */\n\n\n  VisualMapping.listVisualTypes = function () {\n    return zrUtil.keys(VisualMapping.visualHandlers);\n  }; // /**\n  //  * @public\n  //  */\n  // static addVisualHandler(name, handler) {\n  //     visualHandlers[name] = handler;\n  // }\n\n  /**\n   * @public\n   */\n\n\n  VisualMapping.isValidType = function (visualType) {\n    return VisualMapping.visualHandlers.hasOwnProperty(visualType);\n  };\n  /**\n   * Convinent method.\n   * Visual can be Object or Array or primary type.\n   */\n\n\n  VisualMapping.eachVisual = function (visual, callback, context) {\n    if (zrUtil.isObject(visual)) {\n      zrUtil.each(visual, callback, context);\n    } else {\n      callback.call(context, visual);\n    }\n  };\n\n  VisualMapping.mapVisual = function (visual, callback, context) {\n    var isPrimary;\n    var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n    VisualMapping.eachVisual(visual, function (v, key) {\n      var newVal = callback.call(context, v, key);\n      isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n    });\n    return newVisual;\n  };\n  /**\n   * Retrieve visual properties from given object.\n   */\n\n\n  VisualMapping.retrieveVisuals = function (obj) {\n    var ret = {};\n    var hasVisual;\n    obj && each(VisualMapping.visualHandlers, function (h, visualType) {\n      if (obj.hasOwnProperty(visualType)) {\n        ret[visualType] = obj[visualType];\n        hasVisual = true;\n      }\n    });\n    return hasVisual ? ret : null;\n  };\n  /**\n   * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\n   *\n   * @public\n   * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\n   *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\n   * @return {Array.<string>} Sorted visual types.\n   */\n\n\n  VisualMapping.prepareVisualTypes = function (visualTypes) {\n    if (zrUtil.isArray(visualTypes)) {\n      visualTypes = visualTypes.slice();\n    } else if (isObject(visualTypes)) {\n      var types_1 = [];\n      each(visualTypes, function (item, type) {\n        types_1.push(type);\n      });\n      visualTypes = types_1;\n    } else {\n      return [];\n    }\n\n    visualTypes.sort(function (type1, type2) {\n      // color should be front of colorSaturation, colorAlpha, ...\n      // symbol and symbolSize do not matter.\n      return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n    });\n    return visualTypes;\n  };\n  /**\n   * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\n   * Other visuals are only depends on themself.\n   */\n\n\n  VisualMapping.dependsOn = function (visualType1, visualType2) {\n    return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n  };\n  /**\n   * @param value\n   * @param pieceList [{value: ..., interval: [min, max]}, ...]\n   *                         Always from small to big.\n   * @param findClosestWhenOutside Default to be false\n   * @return index\n   */\n\n\n  VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n    var possibleI;\n    var abs = Infinity; // value has the higher priority.\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var pieceValue = pieceList[i].value;\n\n      if (pieceValue != null) {\n        if (pieceValue === value // FIXME\n        // It is supposed to compare value according to value type of dimension,\n        // but currently value type can exactly be string or number.\n        // Compromise for numeric-like string (like '12'), especially\n        // in the case that visualMap.categories is ['22', '33'].\n        || typeof pieceValue === 'string' && pieceValue === value + '') {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(pieceValue, i);\n      }\n    }\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var piece = pieceList[i];\n      var interval = piece.interval;\n      var close_1 = piece.close;\n\n      if (interval) {\n        if (interval[0] === -Infinity) {\n          if (littleThan(close_1[1], value, interval[1])) {\n            return i;\n          }\n        } else if (interval[1] === Infinity) {\n          if (littleThan(close_1[0], interval[0], value)) {\n            return i;\n          }\n        } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(interval[0], i);\n        findClosestWhenOutside && updatePossible(interval[1], i);\n      }\n    }\n\n    if (findClosestWhenOutside) {\n      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n    }\n\n    function updatePossible(val, index) {\n      var newAbs = Math.abs(val - value);\n\n      if (newAbs < abs) {\n        abs = newAbs;\n        possibleI = index;\n      }\n    }\n  };\n\n  VisualMapping.visualHandlers = {\n    color: {\n      applyVisual: makeApplyVisual('color'),\n      getColorMapper: function () {\n        var thisOption = this.option;\n        return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n          !isNormalized && (value = this._normalizeData(value));\n          return doMapCategory.call(this, value);\n        } : function (value, isNormalized, out) {\n          // If output rgb array\n          // which will be much faster and useful in pixel manipulation\n          var returnRGBArray = !!out;\n          !isNormalized && (value = this._normalizeData(value));\n          out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n          return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n        }, this);\n      },\n      _normalizedToVisual: {\n        linear: function (normalized) {\n          return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        },\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    colorHue: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, value);\n    }),\n    colorSaturation: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, value);\n    }),\n    colorLightness: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, null, value);\n    }),\n    colorAlpha: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyAlpha(color, value);\n    }),\n    decal: {\n      applyVisual: makeApplyVisual('decal'),\n      _normalizedToVisual: {\n        linear: null,\n        category: doMapCategory,\n        piecewise: null,\n        fixed: null\n      }\n    },\n    opacity: {\n      applyVisual: makeApplyVisual('opacity'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    },\n    liftZ: {\n      applyVisual: makeApplyVisual('liftZ'),\n      _normalizedToVisual: {\n        linear: doMapFixed,\n        category: doMapFixed,\n        piecewise: doMapFixed,\n        fixed: doMapFixed\n      }\n    },\n    symbol: {\n      applyVisual: function (value, getter, setter) {\n        var symbolCfg = this.mapValueToVisual(value);\n        setter('symbol', symbolCfg);\n      },\n      _normalizedToVisual: {\n        linear: doMapToArray,\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = doMapToArray.call(this, normalized);\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    symbolSize: {\n      applyVisual: makeApplyVisual('symbolSize'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    }\n  };\n  return VisualMapping;\n}();\n\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var categoryMap = thisOption.categoryMap = {};\n  var visual = thisOption.visual;\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr_1 = [];\n\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n\n    visual = setVisualToOption(thisOption, visualArr_1);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n\n  setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function (value, getter, setter) {\n      // Only used in HSL\n      var colorChannel = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), colorChannel));\n    },\n    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n  };\n}\n\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {}; // TODO {}?\n}\n\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\n\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\n\nfunction doMapFixed() {\n  // visual will be convert to array.\n  return this.option.visual[0];\n}\n/**\n * Create mapped to numeric visual\n */\n\n\nfunction createNormalizedToNumericVisual(sourceExtent) {\n  return {\n    linear: function (normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function (normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\n\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      return zrColor.parse(item);\n    });\n  }\n\n  return visualArr;\n}\n/**\n * Normalizers by mapping methods.\n */\n\n\nvar normalizers = {\n  linear: function (value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function (value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function (value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal value\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\n\nexport default VisualMapping;","map":{"version":3,"names":["zrUtil","zrColor","linearMap","each","isObject","CATEGORY_DEFAULT_VISUAL_INDEX","VisualMapping","option","mappingMethod","visualType","type","thisOption","clone","_normalizeData","normalizers","visualHandler","visualHandlers","applyVisual","getColorMapper","_normalizedToVisual","normalizeVisualRange","preprocessForPiecewise","categories","preprocessForSpecifiedCategory","assert","dataExtent","prototype","mapValueToVisual","value","normalized","getNormalizer","bind","listVisualTypes","keys","isValidType","hasOwnProperty","eachVisual","visual","callback","context","call","mapVisual","isPrimary","newVisual","isArray","v","key","newVal","retrieveVisuals","obj","ret","hasVisual","h","prepareVisualTypes","visualTypes","slice","types_1","item","push","sort","type1","type2","indexOf","dependsOn","visualType1","visualType2","findPieceIndex","pieceList","findClosestWhenOutside","possibleI","abs","Infinity","i","len","length","pieceValue","updatePossible","piece","interval","close_1","close","littleThan","val","index","newAbs","Math","color","makeApplyVisual","isNormalized","doMapCategory","out","returnRGBArray","fastLerp","parsedVisual","stringify","linear","category","piecewise","result","getSpecifiedVisual","fixed","doMapFixed","colorHue","makePartialColorVisualHandler","modifyHSL","colorSaturation","colorLightness","colorAlpha","modifyAlpha","decal","opacity","createNormalizedToNumericVisual","liftZ","symbol","getter","setter","symbolCfg","doMapToArray","symbolSize","hasSpecialVisual","originIndex","categoryMap","cate","visualArr_1","setVisualToOption","pop","isCategory","visualArr","doNotNeedPair","applyValue","colorChannel","round","loop","sourceExtent","pieceIndex","map","parse","noop","a","b"],"sources":["E:/school/qianduan/web/vue-manage/node_modules/echarts/lib/visual/VisualMapping.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as zrUtil from 'zrender/lib/core/util';\nimport * as zrColor from 'zrender/lib/tool/color';\nimport { linearMap } from '../util/number';\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n\nvar VisualMapping =\n/** @class */\nfunction () {\n  function VisualMapping(option) {\n    var mappingMethod = option.mappingMethod;\n    var visualType = option.type;\n    var thisOption = this.option = zrUtil.clone(option);\n    this.type = visualType;\n    this.mappingMethod = mappingMethod;\n    this._normalizeData = normalizers[mappingMethod];\n    var visualHandler = VisualMapping.visualHandlers[visualType];\n    this.applyVisual = visualHandler.applyVisual;\n    this.getColorMapper = visualHandler.getColorMapper;\n    this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod];\n\n    if (mappingMethod === 'piecewise') {\n      normalizeVisualRange(thisOption);\n      preprocessForPiecewise(thisOption);\n    } else if (mappingMethod === 'category') {\n      thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n      // which need no more preprocess except normalize visual.\n      : normalizeVisualRange(thisOption, true);\n    } else {\n      // mappingMethod === 'linear' or 'fixed'\n      zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n      normalizeVisualRange(thisOption);\n    }\n  }\n\n  VisualMapping.prototype.mapValueToVisual = function (value) {\n    var normalized = this._normalizeData(value);\n\n    return this._normalizedToVisual(normalized, value);\n  };\n\n  VisualMapping.prototype.getNormalizer = function () {\n    return zrUtil.bind(this._normalizeData, this);\n  };\n  /**\n   * List available visual types.\n   *\n   * @public\n   * @return {Array.<string>}\n   */\n\n\n  VisualMapping.listVisualTypes = function () {\n    return zrUtil.keys(VisualMapping.visualHandlers);\n  }; // /**\n  //  * @public\n  //  */\n  // static addVisualHandler(name, handler) {\n  //     visualHandlers[name] = handler;\n  // }\n\n  /**\n   * @public\n   */\n\n\n  VisualMapping.isValidType = function (visualType) {\n    return VisualMapping.visualHandlers.hasOwnProperty(visualType);\n  };\n  /**\n   * Convinent method.\n   * Visual can be Object or Array or primary type.\n   */\n\n\n  VisualMapping.eachVisual = function (visual, callback, context) {\n    if (zrUtil.isObject(visual)) {\n      zrUtil.each(visual, callback, context);\n    } else {\n      callback.call(context, visual);\n    }\n  };\n\n  VisualMapping.mapVisual = function (visual, callback, context) {\n    var isPrimary;\n    var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n    VisualMapping.eachVisual(visual, function (v, key) {\n      var newVal = callback.call(context, v, key);\n      isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n    });\n    return newVisual;\n  };\n  /**\n   * Retrieve visual properties from given object.\n   */\n\n\n  VisualMapping.retrieveVisuals = function (obj) {\n    var ret = {};\n    var hasVisual;\n    obj && each(VisualMapping.visualHandlers, function (h, visualType) {\n      if (obj.hasOwnProperty(visualType)) {\n        ret[visualType] = obj[visualType];\n        hasVisual = true;\n      }\n    });\n    return hasVisual ? ret : null;\n  };\n  /**\n   * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\n   *\n   * @public\n   * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\n   *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\n   * @return {Array.<string>} Sorted visual types.\n   */\n\n\n  VisualMapping.prepareVisualTypes = function (visualTypes) {\n    if (zrUtil.isArray(visualTypes)) {\n      visualTypes = visualTypes.slice();\n    } else if (isObject(visualTypes)) {\n      var types_1 = [];\n      each(visualTypes, function (item, type) {\n        types_1.push(type);\n      });\n      visualTypes = types_1;\n    } else {\n      return [];\n    }\n\n    visualTypes.sort(function (type1, type2) {\n      // color should be front of colorSaturation, colorAlpha, ...\n      // symbol and symbolSize do not matter.\n      return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n    });\n    return visualTypes;\n  };\n  /**\n   * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\n   * Other visuals are only depends on themself.\n   */\n\n\n  VisualMapping.dependsOn = function (visualType1, visualType2) {\n    return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n  };\n  /**\n   * @param value\n   * @param pieceList [{value: ..., interval: [min, max]}, ...]\n   *                         Always from small to big.\n   * @param findClosestWhenOutside Default to be false\n   * @return index\n   */\n\n\n  VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n    var possibleI;\n    var abs = Infinity; // value has the higher priority.\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var pieceValue = pieceList[i].value;\n\n      if (pieceValue != null) {\n        if (pieceValue === value // FIXME\n        // It is supposed to compare value according to value type of dimension,\n        // but currently value type can exactly be string or number.\n        // Compromise for numeric-like string (like '12'), especially\n        // in the case that visualMap.categories is ['22', '33'].\n        || typeof pieceValue === 'string' && pieceValue === value + '') {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(pieceValue, i);\n      }\n    }\n\n    for (var i = 0, len = pieceList.length; i < len; i++) {\n      var piece = pieceList[i];\n      var interval = piece.interval;\n      var close_1 = piece.close;\n\n      if (interval) {\n        if (interval[0] === -Infinity) {\n          if (littleThan(close_1[1], value, interval[1])) {\n            return i;\n          }\n        } else if (interval[1] === Infinity) {\n          if (littleThan(close_1[0], interval[0], value)) {\n            return i;\n          }\n        } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {\n          return i;\n        }\n\n        findClosestWhenOutside && updatePossible(interval[0], i);\n        findClosestWhenOutside && updatePossible(interval[1], i);\n      }\n    }\n\n    if (findClosestWhenOutside) {\n      return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n    }\n\n    function updatePossible(val, index) {\n      var newAbs = Math.abs(val - value);\n\n      if (newAbs < abs) {\n        abs = newAbs;\n        possibleI = index;\n      }\n    }\n  };\n\n  VisualMapping.visualHandlers = {\n    color: {\n      applyVisual: makeApplyVisual('color'),\n      getColorMapper: function () {\n        var thisOption = this.option;\n        return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n          !isNormalized && (value = this._normalizeData(value));\n          return doMapCategory.call(this, value);\n        } : function (value, isNormalized, out) {\n          // If output rgb array\n          // which will be much faster and useful in pixel manipulation\n          var returnRGBArray = !!out;\n          !isNormalized && (value = this._normalizeData(value));\n          out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n          return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n        }, this);\n      },\n      _normalizedToVisual: {\n        linear: function (normalized) {\n          return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        },\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    colorHue: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, value);\n    }),\n    colorSaturation: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, value);\n    }),\n    colorLightness: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyHSL(color, null, null, value);\n    }),\n    colorAlpha: makePartialColorVisualHandler(function (color, value) {\n      return zrColor.modifyAlpha(color, value);\n    }),\n    decal: {\n      applyVisual: makeApplyVisual('decal'),\n      _normalizedToVisual: {\n        linear: null,\n        category: doMapCategory,\n        piecewise: null,\n        fixed: null\n      }\n    },\n    opacity: {\n      applyVisual: makeApplyVisual('opacity'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    },\n    liftZ: {\n      applyVisual: makeApplyVisual('liftZ'),\n      _normalizedToVisual: {\n        linear: doMapFixed,\n        category: doMapFixed,\n        piecewise: doMapFixed,\n        fixed: doMapFixed\n      }\n    },\n    symbol: {\n      applyVisual: function (value, getter, setter) {\n        var symbolCfg = this.mapValueToVisual(value);\n        setter('symbol', symbolCfg);\n      },\n      _normalizedToVisual: {\n        linear: doMapToArray,\n        category: doMapCategory,\n        piecewise: function (normalized, value) {\n          var result = getSpecifiedVisual.call(this, value);\n\n          if (result == null) {\n            result = doMapToArray.call(this, normalized);\n          }\n\n          return result;\n        },\n        fixed: doMapFixed\n      }\n    },\n    symbolSize: {\n      applyVisual: makeApplyVisual('symbolSize'),\n      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n    }\n  };\n  return VisualMapping;\n}();\n\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var categoryMap = thisOption.categoryMap = {};\n  var visual = thisOption.visual;\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr_1 = [];\n\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n\n    visual = setVisualToOption(thisOption, visualArr_1);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n\n  setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function (value, getter, setter) {\n      // Only used in HSL\n      var colorChannel = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), colorChannel));\n    },\n    _normalizedToVisual: createNormalizedToNumericVisual([0, 1])\n  };\n}\n\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {}; // TODO {}?\n}\n\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\n\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\n\nfunction doMapFixed() {\n  // visual will be convert to array.\n  return this.option.visual[0];\n}\n/**\n * Create mapped to numeric visual\n */\n\n\nfunction createNormalizedToNumericVisual(sourceExtent) {\n  return {\n    linear: function (normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function (normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\n\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      return zrColor.parse(item);\n    });\n  }\n\n  return visualArr;\n}\n/**\n * Normalizers by mapping methods.\n */\n\n\nvar normalizers = {\n  linear: function (value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function (value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function (value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal value\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\n\nexport default VisualMapping;"],"mappings":"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"},"metadata":{},"sourceType":"module"}