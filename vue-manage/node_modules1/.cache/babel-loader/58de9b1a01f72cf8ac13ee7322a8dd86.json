{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/esnext.typed-array.find-last.js\";\nimport \"core-js/modules/esnext.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.error.cause.js\";\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n\n/**\n * List for data storage\n */\nimport * as zrUtil from 'zrender/lib/core/util';\nimport Model from '../model/Model';\nimport DataDiffer from './DataDiffer';\nimport { DefaultDataProvider } from './helper/dataProvider';\nimport { summarizeDimensions } from './helper/dimensionHelper';\nimport DataDimensionInfo from './DataDimensionInfo';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../util/types';\nimport { isDataItemOption, convertOptionIdName } from '../util/model';\nimport { getECData } from '../util/innerStore';\nimport { parseDataValue } from './helper/dataValueHelper';\nimport { isSourceInstance } from './Source';\nvar mathFloor = Math.floor;\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent']; // -----------------------------\n// Internal method declarations:\n// -----------------------------\n\nvar defaultDimValueGetters;\nvar prepareInvertedIndex;\nvar getIndicesCtor;\nvar prepareStorage;\nvar getRawIndexWithoutIndices;\nvar getRawIndexWithIndices;\nvar getId;\nvar getIdNameFromStore;\nvar makeIdFromName;\nvar normalizeDimensions;\nvar validateDimensions;\nvar cloneListForMapAndSample;\nvar getInitialExtent;\nvar setItemDataAndSeriesIndex;\nvar transferProperties;\n\nvar List =\n/** @class */\nfunction () {\n  /**\n   * @param dimensions\n   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n   */\n  function List(dimensions, hostModel) {\n    this.type = 'list';\n    this._count = 0;\n    this._rawCount = 0;\n    this._storage = {}; // We have an extra array store here. It's faster to be acessed than KV structured `_storage`.\n    // We profile the code `storage[dim]` and it seems to be KeyedLoadIC_Megamorphic instead of fast property access.\n    // Not sure why this happens. But using an extra array seems leads to faster `initData`\n    // See https://github.com/apache/incubator-echarts/pull/13314 for more explanation.\n\n    this._storageArr = [];\n    this._nameList = [];\n    this._idList = []; // Models of data option is stored sparse for optimizing memory cost\n    // Never used yet (not used yet).\n    // private _optionModels: Model[] = [];\n    // Global visual properties after visual coding\n\n    this._visual = {}; // Globel layout properties.\n\n    this._layout = {}; // Item visual properties after visual coding\n\n    this._itemVisuals = []; // Item layout properties after layout\n\n    this._itemLayouts = []; // Graphic elemnents\n\n    this._graphicEls = []; // Raw extent will not be cloned, but only transfered.\n    // It will not be calculated util needed.\n\n    this._rawExtent = {};\n    this._extent = {}; // key: dim, value: extent\n\n    this._approximateExtent = {};\n    this._calculationInfo = {}; // Having detected that there is data item is non primitive type\n    // (in type `OptionDataItemObject`).\n    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`\n    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.\n\n    this.hasItemOption = true; // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map']; // Methods that change indices of this list should be listed here.\n\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    /**\n     * Get raw data index.\n     * Do not initialize.\n     * Default `getRawIndex`. And it can be changed.\n     */\n\n    this.getRawIndex = getRawIndexWithoutIndices;\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n\n    for (var i = 0; i < dimensions.length; i++) {\n      // Use the original dimensions[i], where other flag props may exists.\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new DataDimensionInfo({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof DataDimensionInfo) ? new DataDimensionInfo(dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n      dimensionInfo.index = i;\n\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n        this._nameOrdinalMeta = dimensionInfo.ordinalMeta;\n      }\n\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n        this._idOrdinalMeta = dimensionInfo.ordinalMeta;\n      }\n    }\n\n    this.dimensions = dimensionNames;\n    this._dimensionInfos = dimensionInfos;\n    this.hostModel = hostModel; // Cache summary info for fast visit. See \"dimensionHelper\".\n\n    this._dimensionsSummary = summarizeDimensions(this);\n    this._invertedIndicesMap = invertedIndicesMap;\n    this.userOutput = this._dimensionsSummary.userOutput;\n  }\n  /**\n   * The meanings of the input parameter `dim`:\n   *\n   * + If dim is a number (e.g., `1`), it means the index of the dimension.\n   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n   * + If dim is a number-like string (e.g., `\"1\"`):\n   *     + If there is the same concrete dim name defined in `this.dimensions`, it means that concrete name.\n   *     + If not, it will be converted to a number, which means the index of the dimension.\n   *        (why? because of the backward compatbility. We have been tolerating number-like string in\n   *        dimension setting, although now it seems that it is not a good idea.)\n   *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n   *     if no dimension name is defined as `\"1\"`.\n   * + If dim is a not-number-like string, it means the concrete dim name.\n   *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n   *   or customized in `dimensions` property of option like `\"age\"`.\n   *\n   * Get dimension name\n   * @param dim See above.\n   * @return Concrete dim name.\n   */\n\n\n  List.prototype.getDimension = function (dim) {\n    if (typeof dim === 'number' // If being a number-like string but not being defined a dimension name.\n    || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n      dim = this.dimensions[dim];\n    }\n\n    return dim;\n  };\n  /**\n   * Get type and calculation info of particular dimension\n   * @param dim\n   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n   */\n\n\n  List.prototype.getDimensionInfo = function (dim) {\n    // Do not clone, because there may be categories in dimInfo.\n    return this._dimensionInfos[this.getDimension(dim)];\n  };\n  /**\n   * concrete dimension name list on coord.\n   */\n\n\n  List.prototype.getDimensionsOnCoord = function () {\n    return this._dimensionsSummary.dataDimsOnCoord.slice();\n  };\n\n  List.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimensionsSummary;\n\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n\n  List.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimensionsSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n  /**\n   * Initialize from data\n   * @param data source or data or data provider.\n   * @param nameList The name of a datum is used on data diff and\n   *        default label/tooltip.\n   *        A name can be specified in encode.itemName,\n   *        or dataItem.name (only for series option data),\n   *        or provided in nameList from outside.\n   */\n\n\n  List.prototype.initData = function (data, nameList, dimValueGetter) {\n    var notProvider = isSourceInstance(data) || zrUtil.isArrayLike(data);\n    var provider = notProvider ? new DefaultDataProvider(data, this.dimensions.length) : data;\n\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(notProvider || zrUtil.isFunction(provider.getItem) && zrUtil.isFunction(provider.count), 'Inavlid data provider.');\n    }\n\n    this._rawData = provider;\n    var sourceFormat = provider.getSource().sourceFormat; // Clear\n\n    this._storage = {};\n    this._indices = null;\n    this._dontMakeIdFromName = this._idDimIdx != null || sourceFormat === SOURCE_FORMAT_TYPED_ARRAY // Cosndier performance.\n    || !!provider.fillStorage;\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n\n    if (!dimValueGetter) {\n      this.hasItemOption = false;\n    }\n\n    this.defaultDimValueGetter = defaultDimValueGetters[sourceFormat]; // Default dim value getter\n\n    this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n    this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows; // Reset raw extent.\n\n    this._rawExtent = {};\n\n    this._initDataFromProvider(0, provider.count()); // If data has no item option.\n\n\n    if (provider.pure) {\n      this.hasItemOption = false;\n    }\n  };\n\n  List.prototype.getProvider = function () {\n    return this._rawData;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n\n  List.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n\n    var rawData = this._rawData;\n    var start = this.count();\n    rawData.appendData(data);\n    var end = rawData.count();\n\n    if (!rawData.persistent) {\n      end += start;\n    }\n\n    this._initDataFromProvider(start, end, true);\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   * This method does not modify `rawData` (`dataProvider`), but only\n   * add values to storage.\n   *\n   * The final count will be increased by `Math.max(values.length, names.length)`.\n   *\n   * @param values That is the SourceType: 'arrayRows', like\n   *        [\n   *            [12, 33, 44],\n   *            [NaN, 43, 1],\n   *            ['-', 'asdf', 0]\n   *        ]\n   *        Each item is exaclty cooresponding to a dimension.\n   */\n\n\n  List.prototype.appendValues = function (values, names) {\n    var storage = this._storage;\n    var dimensions = this.dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, names ? names.length : 0);\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[dim]) {\n        rawExtent[dim] = getInitialExtent();\n      }\n\n      prepareStorage(storage, this._dimensionInfos[dim], end, true);\n    }\n\n    var rawExtentArr = map(dimensions, function (dim) {\n      return rawExtent[dim];\n    });\n    var storageArr = this._storageArr = map(dimensions, function (dim) {\n      return storage[dim];\n    });\n    var emptyDataItem = [];\n\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start; // Store the data by dimensions\n\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n\n        var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, dimIdx);\n\n        storageArr[dimIdx][idx] = val;\n        var dimRawExtent = rawExtentArr[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n\n      if (names) {\n        this._nameList[idx] = names[sourceIdx];\n\n        if (!this._dontMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n\n    this._rawCount = this._count = end; // Reset data extent\n\n    this._extent = {};\n    prepareInvertedIndex(this);\n  };\n\n  List.prototype._initDataFromProvider = function (start, end, append) {\n    if (start >= end) {\n      return;\n    }\n\n    var rawData = this._rawData;\n    var storage = this._storage;\n    var dimensions = this.dimensions;\n    var dimLen = dimensions.length;\n    var dimensionInfoMap = this._dimensionInfos;\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var rawExtent = this._rawExtent;\n    var sourceFormat = rawData.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[dim]) {\n        rawExtent[dim] = getInitialExtent();\n      }\n\n      prepareStorage(storage, dimensionInfoMap[dim], end, append);\n    }\n\n    var storageArr = this._storageArr = map(dimensions, function (dim) {\n      return storage[dim];\n    });\n    var rawExtentArr = map(dimensions, function (dim) {\n      return rawExtent[dim];\n    });\n\n    if (rawData.fillStorage) {\n      rawData.fillStorage(start, end, storageArr, rawExtentArr);\n    } else {\n      var dataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        dataItem = rawData.getItem(idx, dataItem); // Each data item is value\n        // [1, 2]\n        // 2\n        // Bar chart, line chart which uses category axis\n        // only gives the 'y' value. 'x' value is the indices of category\n        // Use a tempValue to normalize the value to be a (x, y) value\n        // Store the data by dimensions\n\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dim = dimensions[dimIdx];\n          var dimStorage = storageArr[dimIdx]; // PENDING NULL is empty or zero\n\n          var val = this._dimValueGetter(dataItem, dim, idx, dimIdx);\n\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtentArr[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        } // If dataItem is {name: ...} or {id: ...}, it has highest priority.\n        // This kind of ids and names are always stored `_nameList` and `_idList`.\n\n\n        if (isFormatOriginal && !rawData.pure && dataItem) {\n          var itemName = dataItem.name;\n\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = convertOptionIdName(itemName, null);\n          }\n\n          var itemId = dataItem.id;\n\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = convertOptionIdName(itemId, null);\n          }\n        }\n\n        if (!this._dontMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n\n    if (!rawData.persistent && rawData.clean) {\n      // Clean unused data if data source is typed array.\n      rawData.clean();\n    }\n\n    this._rawCount = this._count = end; // Reset data extent\n\n    this._extent = {};\n    prepareInvertedIndex(this);\n  };\n\n  List.prototype.count = function () {\n    return this._count;\n  };\n\n  List.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this);\n      newIndices = new Ctor(this.count());\n\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n\n    return newIndices;\n  }; // Get data by index of dimension.\n  // Because in v8 access array by number variable is faster than access object by string variable\n  // Not sure why but the optimization just works.\n\n\n  List.prototype.getByDimIdx = function (dimIdx, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._storageArr[dimIdx];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   * @param dim Dim must be concrete name.\n   */\n\n\n  List.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._storage[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n  /**\n   * @param dim concrete dim\n   */\n\n\n  List.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n\n    var dimStore = this._storage[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n\n  List.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n\n    if (!zrUtil.isArray(dimensions)) {\n      // stack = idx;\n      idx = dimensions;\n      dimensions = this.dimensions;\n    }\n\n    for (var i = 0, len = dimensions.length; i < len; i++) {\n      values.push(this.get(dimensions[i], idx\n      /*, stack */\n      ));\n    }\n\n    return values;\n  };\n  /**\n   * If value is NaN. Inlcuding '-'\n   * Only check the coord dimensions.\n   */\n\n\n  List.prototype.hasValue = function (idx) {\n    var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n\n    for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n      // Ordinal type originally can be string or number.\n      // But when an ordinal type is used on coord, it can\n      // not be string but only number. So we can also use isNaN.\n      if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Get extent of data in one dimension\n   */\n\n\n  List.prototype.getDataExtent = function (dim) {\n    // Make sure use concrete dim as cache name.\n    dim = this.getDimension(dim);\n    var dimData = this._storage[dim];\n    var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));\n\n    if (!dimData) {\n      return initialExtent;\n    } // Make more strict checkings to ensure hitting cache.\n\n\n    var currEnd = this.count(); // let cacheName = [dim, !!stack].join('_');\n    // let cacheName = dim;\n    // Consider the most cases when using data zoom, `getDataExtent`\n    // happened before filtering. We cache raw extent, which is not\n    // necessary to be cleared and recalculated when restore data.\n\n    var useRaw = !this._indices; // && !stack;\n\n    var dimExtent;\n\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n\n    dimExtent = this._extent[dim];\n\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n  /**\n   * PENDING: In fact currently this function is only used to short-circuit\n   * the calling of `scale.unionExtentFromData` when data have been filtered by modules\n   * like \"dataZoom\". `scale.unionExtentFromData` is used to calculate data extent for series on\n   * an axis, but if a \"axis related data filter module\" is used, the extent of the axis have\n   * been fixed and no need to calling `scale.unionExtentFromData` actually.\n   * But if we add \"custom data filter\" in future, which is not \"axis related\", this method may\n   * be still needed.\n   *\n   * Optimize for the scenario that data is filtered by a given extent.\n   * Consider that if data amount is more than hundreds of thousand,\n   * extent calculation will cost more than 10ms and the cache will\n   * be erased because of the filtering.\n   */\n\n\n  List.prototype.getApproximateExtent = function (dim) {\n    dim = this.getDimension(dim);\n    return this._approximateExtent[dim] || this.getDataExtent(dim);\n  };\n  /**\n   * Calculate extent on a filtered data might be time consuming.\n   * Approximate extent is only used for: calculte extent of filtered data outside.\n   */\n\n\n  List.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n\n  List.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n\n  List.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n  /**\n   * Get sum of data in one dimension\n   */\n\n\n  List.prototype.getSum = function (dim) {\n    var dimData = this._storage[dim];\n    var sum = 0;\n\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n\n    return sum;\n  };\n  /**\n   * Get median of data in one dimension\n   */\n\n\n  List.prototype.getMedian = function (dim) {\n    var dimDataArray = []; // map all data of one dimension\n\n    this.each(dim, function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    }); // TODO\n    // Use quick select?\n\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count(); // calculate median\n\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  }; // /**\n  //  * Retreive the index with given value\n  //  * @param {string} dim Concrete dimension.\n  //  * @param {number} value\n  //  * @return {number}\n  //  */\n  // Currently incorrect: should return dataIndex but not rawIndex.\n  // Do not fix it until this method is to be used somewhere.\n  // FIXME Precision of float value\n  // indexOf(dim, value) {\n  //     let storage = this._storage;\n  //     let dimData = storage[dim];\n  //     let chunkSize = this._chunkSize;\n  //     if (dimData) {\n  //         for (let i = 0, len = this.count(); i < len; i++) {\n  //             let chunkIndex = mathFloor(i / chunkSize);\n  //             let chunkOffset = i % chunkSize;\n  //             if (dimData[chunkIndex][chunkOffset] === value) {\n  //                 return i;\n  //             }\n  //         }\n  //     }\n  //     return -1;\n  // }\n\n  /**\n   * Only support the dimension which inverted index created.\n   * Do not support other cases until required.\n   * @param dim concrete dim\n   * @param value ordinal index\n   * @return rawIndex\n   */\n\n\n  List.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n\n    var rawIndex = invertedIndices[value];\n\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n\n    return rawIndex;\n  };\n  /**\n   * Retreive the index with given name\n   */\n\n\n  List.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Retreive the index with given raw data index\n   */\n\n\n  List.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n\n    if (!this._indices) {\n      return rawIndex;\n    } // Indices are ascending\n\n\n    var indices = this._indices; // If rawIndex === dataIndex\n\n    var rawDataIndex = indices[rawIndex];\n\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n\n    var left = 0;\n    var right = this._count - 1;\n\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Retreive the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n\n  List.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var storage = this._storage;\n    var dimData = storage[dim];\n    var nearestIndices = [];\n\n    if (!dimData) {\n      return nearestIndices;\n    }\n\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/List.js`.\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n\n      if (dist <= maxDistance) {\n        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n        // So we chose the one that `diff >= 0` in this csae.\n        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n        // should be push to `nearestIndices`.\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n  /**\n   * Get raw data item\n   */\n\n\n  List.prototype.getRawDataItem = function (idx) {\n    if (!this._rawData.persistent) {\n      var val = [];\n\n      for (var i = 0; i < this.dimensions.length; i++) {\n        var dim = this.dimensions[i];\n        val.push(this.get(dim, idx));\n      }\n\n      return val;\n    } else {\n      return this._rawData.getItem(this.getRawIndex(idx));\n    }\n  };\n  /**\n   * @return Never be null/undefined. `number` will be converted to string. Becuase:\n   * In most cases, name is used in display, where returning a string is more convenient.\n   * In other cases, name is used in query (see `indexOfName`), where we can keep the\n   * rule that name `2` equals to name `'2'`.\n   */\n\n\n  List.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, this._nameOrdinalMeta, rawIndex);\n    }\n\n    if (name == null) {\n      name = '';\n    }\n\n    return name;\n  };\n  /**\n   * @return Never null/undefined. `number` will be converted to string. Becuase:\n   * In all cases having encountered at present, id is used in making diff comparison, which\n   * are usually based on hash map. We can keep the rule that the internal id are always string\n   * (treat `2` is the same as `'2'`) to make the related logic simple.\n   */\n\n\n  List.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n\n  List.prototype.each = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var _this = this;\n\n    if (!this._count) {\n      return;\n    }\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var dimSize = dimNames.length;\n    var dimIndices = map(dimNames, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var storageArr = this._storageArr;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i); // Simple optimization\n\n      switch (dimSize) {\n        case 0:\n          cb.call(fCtx, i);\n          break;\n\n        case 1:\n          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], i);\n          break;\n\n        case 2:\n          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], storageArr[dimIndices[1]][rawIdx], i);\n          break;\n\n        default:\n          var k = 0;\n          var value = [];\n\n          for (; k < dimSize; k++) {\n            value[k] = storageArr[dimIndices[k]][rawIdx];\n          } // Index\n\n\n          value[k] = i;\n          cb.apply(fCtx, value);\n      }\n    }\n  };\n\n  List.prototype.filterSelf = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var _this = this;\n\n    if (!this._count) {\n      return;\n    }\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var count = this.count();\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dimNames.length;\n    var offset = 0;\n    var dimIndices = map(dimNames, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var dim0 = dimIndices[0];\n    var storageArr = this._storageArr;\n\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = this.getRawIndex(i); // Simple optimization\n\n      if (dimSize === 0) {\n        keep = cb.call(fCtx, i);\n      } else if (dimSize === 1) {\n        var val = storageArr[dim0][rawIdx];\n        keep = cb.call(fCtx, val, i);\n      } else {\n        var k = 0;\n\n        for (; k < dimSize; k++) {\n          value[k] = storageArr[dimIndices[k]][rawIdx];\n        }\n\n        value[k] = i;\n        keep = cb.apply(fCtx, value);\n      }\n\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < count) {\n      this._indices = newIndices;\n    }\n\n    this._count = offset; // Reset data extent\n\n    this._extent = {};\n    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return this;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n\n  List.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n\n    var len = this._count;\n\n    if (!len) {\n      return;\n    }\n\n    var dimensions = [];\n\n    for (var dim in range) {\n      if (range.hasOwnProperty(dim)) {\n        dimensions.push(dim);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimensions);\n    }\n\n    var dimSize = dimensions.length;\n\n    if (!dimSize) {\n      return;\n    }\n\n    var originalCount = this.count();\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dimensions[0];\n    var dimIndices = map(dimensions, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storageArr = this._storageArr;\n    var quickFinished = false;\n\n    if (!this._indices) {\n      // Extreme optimization for common case. About 2x faster in chrome.\n      var idx = 0;\n\n      if (dimSize === 1) {\n        var dimStorage = storageArr[dimIndices[0]];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storageArr[dimIndices[0]];\n        var dimStorage2 = storageArr[dimIndices[1]];\n        var min2 = range[dimensions[1]][0];\n        var max2 = range[dimensions[1]][1];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      }\n    }\n\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = this.getRawIndex(i);\n          var val = storageArr[dimIndices[0]][rawIndex]; // Do not filter NaN, see comment above.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = this.getRawIndex(i);\n\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dimensions[k];\n            var val = storageArr[dimIndices[k]][rawIndex]; // Do not filter NaN, see comment above.\n\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n\n          if (keep) {\n            newIndices[offset++] = this.getRawIndex(i);\n          }\n        }\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < originalCount) {\n      this._indices = newIndices;\n    }\n\n    this._count = offset; // Reset data extent\n\n    this._extent = {};\n    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return this;\n  };\n  /* eslint-enable */\n\n\n  List.prototype.mapArray = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    ctx = ctx || ctxCompat || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n\n  List.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict'; // ctxCompat just for compat echarts3\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var list = cloneListForMapAndSample(this, dimNames);\n    var storage = list._storage; // Following properties are all immutable.\n    // So we can reference to the same value\n\n    list._indices = this._indices;\n    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    var tmpRetValue = [];\n    var dimSize = dimNames.length;\n    var dataCount = this.count();\n    var values = [];\n    var rawExtent = list._rawExtent;\n\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n        values[dimIndex] = this.get(dimNames[dimIndex], dataIndex);\n      }\n\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(fCtx, values);\n\n      if (retValue != null) {\n        // a number or string (in oridinal dimension)?\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n\n        var rawIndex = this.getRawIndex(dataIndex);\n\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dimNames[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = storage[dim];\n\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n\n    return list;\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n\n  List.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this, [dimension]);\n    var targetStorage = list._storage;\n    var frameValues = [];\n    var frameSize = mathFloor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = list._rawExtent[dimension];\n    var newIndices = new (getIndicesCtor(this))(len);\n    var offset = 0;\n\n    for (var i = 0; i < len; i += frameSize) {\n      // Last frame\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)); // Only write value on the filtered data\n\n      dimStore[sampleFrameIdx] = value;\n\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n\n      newIndices[offset++] = sampleFrameIdx;\n    }\n\n    list._count = offset;\n    list._indices = newIndices;\n    list.getRawIndex = getRawIndexWithIndices;\n    return list;\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n\n  List.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this, []);\n    var targetStorage = list._storage;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var newIndices = new (getIndicesCtor(this))(len);\n    var sampledIndex = 0;\n    var frameSize = mathFloor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex; // First frame use the first data.\n\n    newIndices[sampledIndex++] = currentRawIndex;\n\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        avgY += y;\n      }\n\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart; // Find a point from current frame that construct a triangel with largest area with previous selected point\n      // And the average of next frame.\n\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        } // Calculate triangle area over three buckets\n\n\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex; // Next a is this b\n        }\n      }\n\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)\n    } // First frame use the last data.\n\n\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    list._count = sampledIndex;\n    list._indices = newIndices;\n    list.getRawIndex = getRawIndexWithIndices;\n    return list;\n  };\n  /**\n   * Get model of one data item.\n   */\n  // TODO: Type of data item\n\n\n  List.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n  /**\n   * Create a data differ\n   */\n\n\n  List.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n  /**\n   * Get visual property.\n   */\n\n\n  List.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n\n  List.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n  /**\n   * Get visual property of single data item\n   */\n  // eslint-disable-next-line\n\n\n  List.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n\n    if (val == null) {\n      // Use global visual property\n      return this.getVisual(key);\n    }\n\n    return val;\n  };\n  /**\n   * If exists visual property of single data item\n   */\n\n\n  List.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n  /**\n   * Make sure itemVisual property is unique\n   */\n  // TODO: use key to save visual to reduce memory.\n\n\n  List.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n\n    var val = itemVisual[key];\n\n    if (val == null) {\n      val = this.getVisual(key); // TODO Performance?\n\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n\n      itemVisual[key] = val;\n    }\n\n    return val;\n  }; // eslint-disable-next-line\n\n\n  List.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n  /**\n   * Clear itemVisuals and list visual.\n   */\n\n\n  List.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n\n  List.prototype.setLayout = function (key, val) {\n    if (isObject(key)) {\n      for (var name_1 in key) {\n        if (key.hasOwnProperty(name_1)) {\n          this.setLayout(name_1, key[name_1]);\n        }\n      }\n\n      return;\n    }\n\n    this._layout[key] = val;\n  };\n  /**\n   * Get layout property.\n   */\n\n\n  List.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n  /**\n   * Get layout of single data item\n   */\n\n\n  List.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n  /**\n   * Set layout of single data item\n   */\n\n\n  List.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n  /**\n   * Clear all layout of single data item\n   */\n\n\n  List.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n  /**\n   * Set graphic element relative to data. It can be set as null\n   */\n\n\n  List.prototype.setItemGraphicEl = function (idx, el) {\n    var hostModel = this.hostModel;\n\n    if (el) {\n      var ecData = getECData(el); // Add data index and series index for indexing the data by element\n      // Useful in tooltip\n\n      ecData.dataIndex = idx;\n      ecData.dataType = this.dataType;\n      ecData.seriesIndex = hostModel && hostModel.seriesIndex; // TODO: not store dataIndex on children.\n\n      if (el.type === 'group') {\n        el.traverse(setItemDataAndSeriesIndex, el);\n      }\n    }\n\n    this._graphicEls[idx] = el;\n  };\n\n  List.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n\n  List.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n  /**\n   * Shallow clone a new list except visual and layout properties, and graph elements.\n   * New list only change the indices.\n   */\n\n\n  List.prototype.cloneShallow = function (list) {\n    if (!list) {\n      var dimensionInfoList = map(this.dimensions, this.getDimensionInfo, this);\n      list = new List(dimensionInfoList, this.hostModel);\n    } // FIXME\n\n\n    list._storage = this._storage;\n    list._storageArr = this._storageArr;\n    transferProperties(list, this); // Clone will not change the data extent and indices\n\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        list._indices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          list._indices[i] = this._indices[i];\n        }\n      } else {\n        list._indices = new Ctor(this._indices);\n      }\n    } else {\n      list._indices = null;\n    }\n\n    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return list;\n  };\n  /**\n   * Wrap some method to add more feature\n   */\n\n\n  List.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n\n    if (typeof originalMethod !== 'function') {\n      return;\n    }\n\n    this.__wrappedMethods = this.__wrappedMethods || [];\n\n    this.__wrappedMethods.push(methodName);\n\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  }; // ----------------------------------------------------------\n  // A work around for internal method visiting private member.\n  // ----------------------------------------------------------\n\n\n  List.internalField = function () {\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, dimName, dataIndex, dimIndex) {\n        return parseDataValue(dataItem[dimName], this._dimensionInfos[dimName]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, dimName, dataIndex, dimIndex) {\n        // Performance sensitive, do not use modelUtil.getDataItemValue.\n        // If dataItem is an plain object with no value field, the let `value`\n        // will be assigned with the object, but it will be tread correctly\n        // in the `convertValue`.\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value); // If any dataItem is like { value: 10 }\n\n        if (!this._rawData.pure && isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n\n        return parseDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n        : value, this._dimensionInfos[dimName]);\n      },\n      typedArray: function (dataItem, dimName, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n\n    function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {\n      return parseDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);\n    }\n\n    prepareInvertedIndex = function (list) {\n      var invertedIndicesMap = list._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n        var ordinalMeta = dimInfo.ordinalMeta;\n\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n          // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n\n          for (var i = 0; i < list._count; i++) {\n            // Only support the case that all values are distinct.\n            invertedIndices[list.get(dim, i)] = i;\n          }\n        }\n      });\n    };\n\n    getIdNameFromStore = function (list, dimIdx, ordinalMeta, rawIndex) {\n      var val;\n      var chunk = list._storageArr[dimIdx];\n\n      if (chunk) {\n        val = chunk[rawIndex];\n\n        if (ordinalMeta && ordinalMeta.categories.length) {\n          val = ordinalMeta.categories[val];\n        }\n      }\n\n      return convertOptionIdName(val, null);\n    };\n\n    getIndicesCtor = function (list) {\n      // The possible max value in this._indicies is always this._rawCount despite of filtering.\n      return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n    };\n\n    prepareStorage = function (storage, dimInfo, end, append) {\n      var DataCtor = dataCtors[dimInfo.type];\n      var dim = dimInfo.name;\n\n      if (append) {\n        var oldStore = storage[dim];\n        var oldLen = oldStore && oldStore.length;\n\n        if (!(oldLen === end)) {\n          var newStore = new DataCtor(end); // The cost of the copy is probably inconsiderable\n          // within the initial chunkSize.\n\n          for (var j = 0; j < oldLen; j++) {\n            newStore[j] = oldStore[j];\n          }\n\n          storage[dim] = newStore;\n        }\n      } else {\n        storage[dim] = new DataCtor(end);\n      }\n    };\n\n    getRawIndexWithoutIndices = function (idx) {\n      return idx;\n    };\n\n    getRawIndexWithIndices = function (idx) {\n      if (idx < this._count && idx >= 0) {\n        return this._indices[idx];\n      }\n\n      return -1;\n    };\n    /**\n     * @see the comment of `List['getId']`.\n     */\n\n\n    getId = function (list, rawIndex) {\n      var id = list._idList[rawIndex];\n\n      if (id == null && list._idDimIdx != null) {\n        id = getIdNameFromStore(list, list._idDimIdx, list._idOrdinalMeta, rawIndex);\n      }\n\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n\n      return id;\n    };\n\n    normalizeDimensions = function (dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n\n      return dimensions;\n    };\n\n    validateDimensions = function (list, dims) {\n      for (var i = 0; i < dims.length; i++) {\n        // stroage may be empty when no data, so use\n        // dimensionInfos to check.\n        if (!list._dimensionInfos[dims[i]]) {\n          console.error('Unkown dimension ' + dims[i]);\n        }\n      }\n    }; // Data in excludeDimensions is copied, otherwise transfered.\n\n\n    cloneListForMapAndSample = function (original, excludeDimensions) {\n      var allDimensions = original.dimensions;\n      var list = new List(map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n      transferProperties(list, original);\n      var storage = list._storage = {};\n      var originalStorage = original._storage;\n      var storageArr = list._storageArr = []; // Init storage\n\n      for (var i = 0; i < allDimensions.length; i++) {\n        var dim = allDimensions[i];\n\n        if (originalStorage[dim]) {\n          // Notice that we do not reset invertedIndicesMap here, becuase\n          // there is no scenario of mapping or sampling ordinal dimension.\n          if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n            storage[dim] = cloneChunk(originalStorage[dim]);\n            list._rawExtent[dim] = getInitialExtent();\n            list._extent[dim] = null;\n          } else {\n            // Direct reference for other dimensions\n            storage[dim] = originalStorage[dim];\n          }\n\n          storageArr.push(storage[dim]);\n        }\n      }\n\n      return list;\n    };\n\n    function cloneChunk(originalChunk) {\n      var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n      return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n    }\n\n    getInitialExtent = function () {\n      return [Infinity, -Infinity];\n    };\n\n    setItemDataAndSeriesIndex = function (child) {\n      var childECData = getECData(child);\n      var thisECData = getECData(this);\n      childECData.seriesIndex = thisECData.seriesIndex;\n      childECData.dataIndex = thisECData.dataIndex;\n      childECData.dataType = thisECData.dataType;\n    };\n\n    transferProperties = function (target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n\n    makeIdFromName = function (list, idx) {\n      var nameList = list._nameList;\n      var idList = list._idList;\n      var nameDimIdx = list._nameDimIdx;\n      var idDimIdx = list._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(list, nameDimIdx, list._nameOrdinalMeta, idx);\n      }\n\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(list, idDimIdx, list._idOrdinalMeta, idx);\n      }\n\n      if (id == null && name != null) {\n        var nameRepeatCount = list._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n\n        idList[idx] = id;\n      }\n    };\n  }();\n\n  return List;\n}();\n\nexport default List;","map":{"version":3,"names":["zrUtil","Model","DataDiffer","DefaultDataProvider","summarizeDimensions","DataDimensionInfo","SOURCE_FORMAT_TYPED_ARRAY","SOURCE_FORMAT_ORIGINAL","isDataItemOption","convertOptionIdName","getECData","parseDataValue","isSourceInstance","mathFloor","Math","floor","isObject","map","UNDEFINED","INDEX_NOT_FOUND","ID_PREFIX","dataCtors","Float64Array","Array","Int32Array","CtorUint32Array","Uint32Array","CtorInt32Array","CtorUint16Array","Uint16Array","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","defaultDimValueGetters","prepareInvertedIndex","getIndicesCtor","prepareStorage","getRawIndexWithoutIndices","getRawIndexWithIndices","getId","getIdNameFromStore","makeIdFromName","normalizeDimensions","validateDimensions","cloneListForMapAndSample","getInitialExtent","setItemDataAndSeriesIndex","transferProperties","List","dimensions","hostModel","type","_count","_rawCount","_storage","_storageArr","_nameList","_idList","_visual","_layout","_itemVisuals","_itemLayouts","_graphicEls","_rawExtent","_extent","_approximateExtent","_calculationInfo","hasItemOption","TRANSFERABLE_METHODS","CHANGABLE_METHODS","DOWNSAMPLE_METHODS","getRawIndex","dimensionInfos","dimensionNames","invertedIndicesMap","i","length","dimInfoInput","dimensionInfo","isString","name","dimensionName","coordDim","coordDimIndex","otherDims","push","index","createInvertedIndices","itemName","_nameDimIdx","_nameOrdinalMeta","ordinalMeta","itemId","_idDimIdx","_idOrdinalMeta","_dimensionInfos","_dimensionsSummary","_invertedIndicesMap","userOutput","prototype","getDimension","dim","isNaN","hasOwnProperty","getDimensionInfo","getDimensionsOnCoord","dataDimsOnCoord","slice","mapDimension","idx","dimensionsSummary","encodeFirstDimNotExtra","dims","encode","mapDimensionsAll","initData","data","nameList","dimValueGetter","notProvider","isArrayLike","provider","process","env","NODE_ENV","assert","isFunction","getItem","count","_rawData","sourceFormat","getSource","_indices","_dontMakeIdFromName","fillStorage","_nameRepeatCount","defaultDimValueGetter","_dimValueGetter","_dimValueGetterArrayRows","arrayRows","_initDataFromProvider","pure","getProvider","appendData","rawData","start","end","persistent","appendValues","values","names","storage","dimLen","rawExtent","max","rawExtentArr","storageArr","emptyDataItem","sourceIdx","dimIdx","val","dimRawExtent","append","dimensionInfoMap","idList","isFormatOriginal","dataItem","dimStorage","id","clean","getIndices","newIndices","indices","Ctor","constructor","thisCount","buffer","getByDimIdx","NaN","dimStore","get","getByRawIndex","rawIdx","getValues","isArray","len","hasValue","getDataExtent","dimData","initialExtent","currEnd","useRaw","dimExtent","min","value","getApproximateExtent","setApproximateExtent","extent","getCalculationInfo","key","setCalculationInfo","extend","getSum","sum","getMedian","dimDataArray","each","sortedDimDataArray","sort","a","b","rawIndexOf","invertedIndices","Error","rawIndex","indexOfName","getName","indexOfRawIndex","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","Infinity","minDist","minDiff","nearestIndicesLen","dataIndex","diff","dist","abs","getRawDataItem","cb","ctx","ctxCompat","_this","fCtx","dimNames","dimSize","dimIndices","dimName","call","k","apply","filterSelf","offset","dim0","keep","selectRange","range","originalCount","quickFinished","dimStorage2","min2","max2","val2","dimk","mapArray","result","arguments","list","tmpRetValue","dataCount","dimIndex","retValue","rawExtentOnDim","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","frameValues","frameSize","dataIdx","sampleFrameIdx","lttbDownSample","valueDimension","sampledIndex","currentRawIndex","maxArea","area","nextRawIndex","nextFrameStart","nextFrameEnd","avgX","avgY","y","frameStart","frameEnd","pointAX","pointAY","getItemModel","ecModel","otherList","thisList","getVisual","visual","setVisual","kvObj","getItemVisual","itemVisual","hasItemVisual","ensureUniqueItemVisual","itemVisuals","setItemVisual","clearAllVisual","setLayout","name_1","getLayout","getItemLayout","setItemLayout","layout","merge","clearItemLayouts","setItemGraphicEl","el","ecData","dataType","seriesIndex","traverse","getItemGraphicEl","eachItemGraphicEl","context","cloneShallow","dimensionInfoList","wrapMethod","methodName","injectFunction","originalMethod","__wrappedMethods","res","concat","internalField","getDimValueSimply","objectRows","keyedColumns","original","typedArray","dimInfo","categories","chunk","DataCtor","oldStore","oldLen","newStore","j","console","error","excludeDimensions","allDimensions","originalStorage","indexOf","cloneChunk","originalChunk","child","childECData","thisECData","target","source","propName","clone","nameDimIdx","idDimIdx","nameRepeatCount","nmCnt"],"sources":["E:/school/qianduan/web/vue-manage/node_modules/echarts/lib/data/List.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n\n/**\n * List for data storage\n */\nimport * as zrUtil from 'zrender/lib/core/util';\nimport Model from '../model/Model';\nimport DataDiffer from './DataDiffer';\nimport { DefaultDataProvider } from './helper/dataProvider';\nimport { summarizeDimensions } from './helper/dimensionHelper';\nimport DataDimensionInfo from './DataDimensionInfo';\nimport { SOURCE_FORMAT_TYPED_ARRAY, SOURCE_FORMAT_ORIGINAL } from '../util/types';\nimport { isDataItemOption, convertOptionIdName } from '../util/model';\nimport { getECData } from '../util/innerStore';\nimport { parseDataValue } from './helper/dataValueHelper';\nimport { isSourceInstance } from './Source';\nvar mathFloor = Math.floor;\nvar isObject = zrUtil.isObject;\nvar map = zrUtil.map;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent']; // -----------------------------\n// Internal method declarations:\n// -----------------------------\n\nvar defaultDimValueGetters;\nvar prepareInvertedIndex;\nvar getIndicesCtor;\nvar prepareStorage;\nvar getRawIndexWithoutIndices;\nvar getRawIndexWithIndices;\nvar getId;\nvar getIdNameFromStore;\nvar makeIdFromName;\nvar normalizeDimensions;\nvar validateDimensions;\nvar cloneListForMapAndSample;\nvar getInitialExtent;\nvar setItemDataAndSeriesIndex;\nvar transferProperties;\n\nvar List =\n/** @class */\nfunction () {\n  /**\n   * @param dimensions\n   *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n   *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n   */\n  function List(dimensions, hostModel) {\n    this.type = 'list';\n    this._count = 0;\n    this._rawCount = 0;\n    this._storage = {}; // We have an extra array store here. It's faster to be acessed than KV structured `_storage`.\n    // We profile the code `storage[dim]` and it seems to be KeyedLoadIC_Megamorphic instead of fast property access.\n    // Not sure why this happens. But using an extra array seems leads to faster `initData`\n    // See https://github.com/apache/incubator-echarts/pull/13314 for more explanation.\n\n    this._storageArr = [];\n    this._nameList = [];\n    this._idList = []; // Models of data option is stored sparse for optimizing memory cost\n    // Never used yet (not used yet).\n    // private _optionModels: Model[] = [];\n    // Global visual properties after visual coding\n\n    this._visual = {}; // Globel layout properties.\n\n    this._layout = {}; // Item visual properties after visual coding\n\n    this._itemVisuals = []; // Item layout properties after layout\n\n    this._itemLayouts = []; // Graphic elemnents\n\n    this._graphicEls = []; // Raw extent will not be cloned, but only transfered.\n    // It will not be calculated util needed.\n\n    this._rawExtent = {};\n    this._extent = {}; // key: dim, value: extent\n\n    this._approximateExtent = {};\n    this._calculationInfo = {}; // Having detected that there is data item is non primitive type\n    // (in type `OptionDataItemObject`).\n    // Like `data: [ { value: xx, itemStyle: {...} }, ...]`\n    // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.\n\n    this.hasItemOption = true; // Methods that create a new list based on this list should be listed here.\n    // Notice that those method should `RETURN` the new list.\n\n    this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map']; // Methods that change indices of this list should be listed here.\n\n    this.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\n    this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample'];\n    /**\n     * Get raw data index.\n     * Do not initialize.\n     * Default `getRawIndex`. And it can be changed.\n     */\n\n    this.getRawIndex = getRawIndexWithoutIndices;\n    dimensions = dimensions || ['x', 'y'];\n    var dimensionInfos = {};\n    var dimensionNames = [];\n    var invertedIndicesMap = {};\n\n    for (var i = 0; i < dimensions.length; i++) {\n      // Use the original dimensions[i], where other flag props may exists.\n      var dimInfoInput = dimensions[i];\n      var dimensionInfo = zrUtil.isString(dimInfoInput) ? new DataDimensionInfo({\n        name: dimInfoInput\n      }) : !(dimInfoInput instanceof DataDimensionInfo) ? new DataDimensionInfo(dimInfoInput) : dimInfoInput;\n      var dimensionName = dimensionInfo.name;\n      dimensionInfo.type = dimensionInfo.type || 'float';\n\n      if (!dimensionInfo.coordDim) {\n        dimensionInfo.coordDim = dimensionName;\n        dimensionInfo.coordDimIndex = 0;\n      }\n\n      var otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n      dimensionNames.push(dimensionName);\n      dimensionInfos[dimensionName] = dimensionInfo;\n      dimensionInfo.index = i;\n\n      if (dimensionInfo.createInvertedIndices) {\n        invertedIndicesMap[dimensionName] = [];\n      }\n\n      if (otherDims.itemName === 0) {\n        this._nameDimIdx = i;\n        this._nameOrdinalMeta = dimensionInfo.ordinalMeta;\n      }\n\n      if (otherDims.itemId === 0) {\n        this._idDimIdx = i;\n        this._idOrdinalMeta = dimensionInfo.ordinalMeta;\n      }\n    }\n\n    this.dimensions = dimensionNames;\n    this._dimensionInfos = dimensionInfos;\n    this.hostModel = hostModel; // Cache summary info for fast visit. See \"dimensionHelper\".\n\n    this._dimensionsSummary = summarizeDimensions(this);\n    this._invertedIndicesMap = invertedIndicesMap;\n    this.userOutput = this._dimensionsSummary.userOutput;\n  }\n  /**\n   * The meanings of the input parameter `dim`:\n   *\n   * + If dim is a number (e.g., `1`), it means the index of the dimension.\n   *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n   * + If dim is a number-like string (e.g., `\"1\"`):\n   *     + If there is the same concrete dim name defined in `this.dimensions`, it means that concrete name.\n   *     + If not, it will be converted to a number, which means the index of the dimension.\n   *        (why? because of the backward compatbility. We have been tolerating number-like string in\n   *        dimension setting, although now it seems that it is not a good idea.)\n   *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n   *     if no dimension name is defined as `\"1\"`.\n   * + If dim is a not-number-like string, it means the concrete dim name.\n   *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n   *   or customized in `dimensions` property of option like `\"age\"`.\n   *\n   * Get dimension name\n   * @param dim See above.\n   * @return Concrete dim name.\n   */\n\n\n  List.prototype.getDimension = function (dim) {\n    if (typeof dim === 'number' // If being a number-like string but not being defined a dimension name.\n    || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n      dim = this.dimensions[dim];\n    }\n\n    return dim;\n  };\n  /**\n   * Get type and calculation info of particular dimension\n   * @param dim\n   *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n   *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n   */\n\n\n  List.prototype.getDimensionInfo = function (dim) {\n    // Do not clone, because there may be categories in dimInfo.\n    return this._dimensionInfos[this.getDimension(dim)];\n  };\n  /**\n   * concrete dimension name list on coord.\n   */\n\n\n  List.prototype.getDimensionsOnCoord = function () {\n    return this._dimensionsSummary.dataDimsOnCoord.slice();\n  };\n\n  List.prototype.mapDimension = function (coordDim, idx) {\n    var dimensionsSummary = this._dimensionsSummary;\n\n    if (idx == null) {\n      return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n    }\n\n    var dims = dimensionsSummary.encode[coordDim];\n    return dims ? dims[idx] : null;\n  };\n\n  List.prototype.mapDimensionsAll = function (coordDim) {\n    var dimensionsSummary = this._dimensionsSummary;\n    var dims = dimensionsSummary.encode[coordDim];\n    return (dims || []).slice();\n  };\n  /**\n   * Initialize from data\n   * @param data source or data or data provider.\n   * @param nameList The name of a datum is used on data diff and\n   *        default label/tooltip.\n   *        A name can be specified in encode.itemName,\n   *        or dataItem.name (only for series option data),\n   *        or provided in nameList from outside.\n   */\n\n\n  List.prototype.initData = function (data, nameList, dimValueGetter) {\n    var notProvider = isSourceInstance(data) || zrUtil.isArrayLike(data);\n    var provider = notProvider ? new DefaultDataProvider(data, this.dimensions.length) : data;\n\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(notProvider || zrUtil.isFunction(provider.getItem) && zrUtil.isFunction(provider.count), 'Inavlid data provider.');\n    }\n\n    this._rawData = provider;\n    var sourceFormat = provider.getSource().sourceFormat; // Clear\n\n    this._storage = {};\n    this._indices = null;\n    this._dontMakeIdFromName = this._idDimIdx != null || sourceFormat === SOURCE_FORMAT_TYPED_ARRAY // Cosndier performance.\n    || !!provider.fillStorage;\n    this._nameList = (nameList || []).slice();\n    this._idList = [];\n    this._nameRepeatCount = {};\n\n    if (!dimValueGetter) {\n      this.hasItemOption = false;\n    }\n\n    this.defaultDimValueGetter = defaultDimValueGetters[sourceFormat]; // Default dim value getter\n\n    this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n    this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows; // Reset raw extent.\n\n    this._rawExtent = {};\n\n    this._initDataFromProvider(0, provider.count()); // If data has no item option.\n\n\n    if (provider.pure) {\n      this.hasItemOption = false;\n    }\n  };\n\n  List.prototype.getProvider = function () {\n    return this._rawData;\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   */\n\n\n  List.prototype.appendData = function (data) {\n    if (process.env.NODE_ENV !== 'production') {\n      zrUtil.assert(!this._indices, 'appendData can only be called on raw data.');\n    }\n\n    var rawData = this._rawData;\n    var start = this.count();\n    rawData.appendData(data);\n    var end = rawData.count();\n\n    if (!rawData.persistent) {\n      end += start;\n    }\n\n    this._initDataFromProvider(start, end, true);\n  };\n  /**\n   * Caution: Can be only called on raw data (before `this._indices` created).\n   * This method does not modify `rawData` (`dataProvider`), but only\n   * add values to storage.\n   *\n   * The final count will be increased by `Math.max(values.length, names.length)`.\n   *\n   * @param values That is the SourceType: 'arrayRows', like\n   *        [\n   *            [12, 33, 44],\n   *            [NaN, 43, 1],\n   *            ['-', 'asdf', 0]\n   *        ]\n   *        Each item is exaclty cooresponding to a dimension.\n   */\n\n\n  List.prototype.appendValues = function (values, names) {\n    var storage = this._storage;\n    var dimensions = this.dimensions;\n    var dimLen = dimensions.length;\n    var rawExtent = this._rawExtent;\n    var start = this.count();\n    var end = start + Math.max(values.length, names ? names.length : 0);\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[dim]) {\n        rawExtent[dim] = getInitialExtent();\n      }\n\n      prepareStorage(storage, this._dimensionInfos[dim], end, true);\n    }\n\n    var rawExtentArr = map(dimensions, function (dim) {\n      return rawExtent[dim];\n    });\n    var storageArr = this._storageArr = map(dimensions, function (dim) {\n      return storage[dim];\n    });\n    var emptyDataItem = [];\n\n    for (var idx = start; idx < end; idx++) {\n      var sourceIdx = idx - start; // Store the data by dimensions\n\n      for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n        var dim = dimensions[dimIdx];\n\n        var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, dimIdx);\n\n        storageArr[dimIdx][idx] = val;\n        var dimRawExtent = rawExtentArr[dimIdx];\n        val < dimRawExtent[0] && (dimRawExtent[0] = val);\n        val > dimRawExtent[1] && (dimRawExtent[1] = val);\n      }\n\n      if (names) {\n        this._nameList[idx] = names[sourceIdx];\n\n        if (!this._dontMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n\n    this._rawCount = this._count = end; // Reset data extent\n\n    this._extent = {};\n    prepareInvertedIndex(this);\n  };\n\n  List.prototype._initDataFromProvider = function (start, end, append) {\n    if (start >= end) {\n      return;\n    }\n\n    var rawData = this._rawData;\n    var storage = this._storage;\n    var dimensions = this.dimensions;\n    var dimLen = dimensions.length;\n    var dimensionInfoMap = this._dimensionInfos;\n    var nameList = this._nameList;\n    var idList = this._idList;\n    var rawExtent = this._rawExtent;\n    var sourceFormat = rawData.getSource().sourceFormat;\n    var isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL;\n\n    for (var i = 0; i < dimLen; i++) {\n      var dim = dimensions[i];\n\n      if (!rawExtent[dim]) {\n        rawExtent[dim] = getInitialExtent();\n      }\n\n      prepareStorage(storage, dimensionInfoMap[dim], end, append);\n    }\n\n    var storageArr = this._storageArr = map(dimensions, function (dim) {\n      return storage[dim];\n    });\n    var rawExtentArr = map(dimensions, function (dim) {\n      return rawExtent[dim];\n    });\n\n    if (rawData.fillStorage) {\n      rawData.fillStorage(start, end, storageArr, rawExtentArr);\n    } else {\n      var dataItem = [];\n\n      for (var idx = start; idx < end; idx++) {\n        // NOTICE: Try not to write things into dataItem\n        dataItem = rawData.getItem(idx, dataItem); // Each data item is value\n        // [1, 2]\n        // 2\n        // Bar chart, line chart which uses category axis\n        // only gives the 'y' value. 'x' value is the indices of category\n        // Use a tempValue to normalize the value to be a (x, y) value\n        // Store the data by dimensions\n\n        for (var dimIdx = 0; dimIdx < dimLen; dimIdx++) {\n          var dim = dimensions[dimIdx];\n          var dimStorage = storageArr[dimIdx]; // PENDING NULL is empty or zero\n\n          var val = this._dimValueGetter(dataItem, dim, idx, dimIdx);\n\n          dimStorage[idx] = val;\n          var dimRawExtent = rawExtentArr[dimIdx];\n          val < dimRawExtent[0] && (dimRawExtent[0] = val);\n          val > dimRawExtent[1] && (dimRawExtent[1] = val);\n        } // If dataItem is {name: ...} or {id: ...}, it has highest priority.\n        // This kind of ids and names are always stored `_nameList` and `_idList`.\n\n\n        if (isFormatOriginal && !rawData.pure && dataItem) {\n          var itemName = dataItem.name;\n\n          if (nameList[idx] == null && itemName != null) {\n            nameList[idx] = convertOptionIdName(itemName, null);\n          }\n\n          var itemId = dataItem.id;\n\n          if (idList[idx] == null && itemId != null) {\n            idList[idx] = convertOptionIdName(itemId, null);\n          }\n        }\n\n        if (!this._dontMakeIdFromName) {\n          makeIdFromName(this, idx);\n        }\n      }\n    }\n\n    if (!rawData.persistent && rawData.clean) {\n      // Clean unused data if data source is typed array.\n      rawData.clean();\n    }\n\n    this._rawCount = this._count = end; // Reset data extent\n\n    this._extent = {};\n    prepareInvertedIndex(this);\n  };\n\n  List.prototype.count = function () {\n    return this._count;\n  };\n\n  List.prototype.getIndices = function () {\n    var newIndices;\n    var indices = this._indices;\n\n    if (indices) {\n      var Ctor = indices.constructor;\n      var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n      if (Ctor === Array) {\n        newIndices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          newIndices[i] = indices[i];\n        }\n      } else {\n        newIndices = new Ctor(indices.buffer, 0, thisCount);\n      }\n    } else {\n      var Ctor = getIndicesCtor(this);\n      newIndices = new Ctor(this.count());\n\n      for (var i = 0; i < newIndices.length; i++) {\n        newIndices[i] = i;\n      }\n    }\n\n    return newIndices;\n  }; // Get data by index of dimension.\n  // Because in v8 access array by number variable is faster than access object by string variable\n  // Not sure why but the optimization just works.\n\n\n  List.prototype.getByDimIdx = function (dimIdx, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._storageArr[dimIdx];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n  /**\n   * Get value. Return NaN if idx is out of range.\n   * @param dim Dim must be concrete name.\n   */\n\n\n  List.prototype.get = function (dim, idx) {\n    if (!(idx >= 0 && idx < this._count)) {\n      return NaN;\n    }\n\n    var dimStore = this._storage[dim];\n    return dimStore ? dimStore[this.getRawIndex(idx)] : NaN;\n  };\n  /**\n   * @param dim concrete dim\n   */\n\n\n  List.prototype.getByRawIndex = function (dim, rawIdx) {\n    if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n      return NaN;\n    }\n\n    var dimStore = this._storage[dim];\n    return dimStore ? dimStore[rawIdx] : NaN;\n  };\n\n  List.prototype.getValues = function (dimensions, idx) {\n    var values = [];\n\n    if (!zrUtil.isArray(dimensions)) {\n      // stack = idx;\n      idx = dimensions;\n      dimensions = this.dimensions;\n    }\n\n    for (var i = 0, len = dimensions.length; i < len; i++) {\n      values.push(this.get(dimensions[i], idx\n      /*, stack */\n      ));\n    }\n\n    return values;\n  };\n  /**\n   * If value is NaN. Inlcuding '-'\n   * Only check the coord dimensions.\n   */\n\n\n  List.prototype.hasValue = function (idx) {\n    var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n\n    for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n      // Ordinal type originally can be string or number.\n      // But when an ordinal type is used on coord, it can\n      // not be string but only number. So we can also use isNaN.\n      if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n  /**\n   * Get extent of data in one dimension\n   */\n\n\n  List.prototype.getDataExtent = function (dim) {\n    // Make sure use concrete dim as cache name.\n    dim = this.getDimension(dim);\n    var dimData = this._storage[dim];\n    var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));\n\n    if (!dimData) {\n      return initialExtent;\n    } // Make more strict checkings to ensure hitting cache.\n\n\n    var currEnd = this.count(); // let cacheName = [dim, !!stack].join('_');\n    // let cacheName = dim;\n    // Consider the most cases when using data zoom, `getDataExtent`\n    // happened before filtering. We cache raw extent, which is not\n    // necessary to be cleared and recalculated when restore data.\n\n    var useRaw = !this._indices; // && !stack;\n\n    var dimExtent;\n\n    if (useRaw) {\n      return this._rawExtent[dim].slice();\n    }\n\n    dimExtent = this._extent[dim];\n\n    if (dimExtent) {\n      return dimExtent.slice();\n    }\n\n    dimExtent = initialExtent;\n    var min = dimExtent[0];\n    var max = dimExtent[1];\n\n    for (var i = 0; i < currEnd; i++) {\n      var rawIdx = this.getRawIndex(i);\n      var value = dimData[rawIdx];\n      value < min && (min = value);\n      value > max && (max = value);\n    }\n\n    dimExtent = [min, max];\n    this._extent[dim] = dimExtent;\n    return dimExtent;\n  };\n  /**\n   * PENDING: In fact currently this function is only used to short-circuit\n   * the calling of `scale.unionExtentFromData` when data have been filtered by modules\n   * like \"dataZoom\". `scale.unionExtentFromData` is used to calculate data extent for series on\n   * an axis, but if a \"axis related data filter module\" is used, the extent of the axis have\n   * been fixed and no need to calling `scale.unionExtentFromData` actually.\n   * But if we add \"custom data filter\" in future, which is not \"axis related\", this method may\n   * be still needed.\n   *\n   * Optimize for the scenario that data is filtered by a given extent.\n   * Consider that if data amount is more than hundreds of thousand,\n   * extent calculation will cost more than 10ms and the cache will\n   * be erased because of the filtering.\n   */\n\n\n  List.prototype.getApproximateExtent = function (dim) {\n    dim = this.getDimension(dim);\n    return this._approximateExtent[dim] || this.getDataExtent(dim);\n  };\n  /**\n   * Calculate extent on a filtered data might be time consuming.\n   * Approximate extent is only used for: calculte extent of filtered data outside.\n   */\n\n\n  List.prototype.setApproximateExtent = function (extent, dim) {\n    dim = this.getDimension(dim);\n    this._approximateExtent[dim] = extent.slice();\n  };\n\n  List.prototype.getCalculationInfo = function (key) {\n    return this._calculationInfo[key];\n  };\n\n  List.prototype.setCalculationInfo = function (key, value) {\n    isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n  };\n  /**\n   * Get sum of data in one dimension\n   */\n\n\n  List.prototype.getSum = function (dim) {\n    var dimData = this._storage[dim];\n    var sum = 0;\n\n    if (dimData) {\n      for (var i = 0, len = this.count(); i < len; i++) {\n        var value = this.get(dim, i);\n\n        if (!isNaN(value)) {\n          sum += value;\n        }\n      }\n    }\n\n    return sum;\n  };\n  /**\n   * Get median of data in one dimension\n   */\n\n\n  List.prototype.getMedian = function (dim) {\n    var dimDataArray = []; // map all data of one dimension\n\n    this.each(dim, function (val) {\n      if (!isNaN(val)) {\n        dimDataArray.push(val);\n      }\n    }); // TODO\n    // Use quick select?\n\n    var sortedDimDataArray = dimDataArray.sort(function (a, b) {\n      return a - b;\n    });\n    var len = this.count(); // calculate median\n\n    return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n  }; // /**\n  //  * Retreive the index with given value\n  //  * @param {string} dim Concrete dimension.\n  //  * @param {number} value\n  //  * @return {number}\n  //  */\n  // Currently incorrect: should return dataIndex but not rawIndex.\n  // Do not fix it until this method is to be used somewhere.\n  // FIXME Precision of float value\n  // indexOf(dim, value) {\n  //     let storage = this._storage;\n  //     let dimData = storage[dim];\n  //     let chunkSize = this._chunkSize;\n  //     if (dimData) {\n  //         for (let i = 0, len = this.count(); i < len; i++) {\n  //             let chunkIndex = mathFloor(i / chunkSize);\n  //             let chunkOffset = i % chunkSize;\n  //             if (dimData[chunkIndex][chunkOffset] === value) {\n  //                 return i;\n  //             }\n  //         }\n  //     }\n  //     return -1;\n  // }\n\n  /**\n   * Only support the dimension which inverted index created.\n   * Do not support other cases until required.\n   * @param dim concrete dim\n   * @param value ordinal index\n   * @return rawIndex\n   */\n\n\n  List.prototype.rawIndexOf = function (dim, value) {\n    var invertedIndices = dim && this._invertedIndicesMap[dim];\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!invertedIndices) {\n        throw new Error('Do not supported yet');\n      }\n    }\n\n    var rawIndex = invertedIndices[value];\n\n    if (rawIndex == null || isNaN(rawIndex)) {\n      return INDEX_NOT_FOUND;\n    }\n\n    return rawIndex;\n  };\n  /**\n   * Retreive the index with given name\n   */\n\n\n  List.prototype.indexOfName = function (name) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      if (this.getName(i) === name) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Retreive the index with given raw data index\n   */\n\n\n  List.prototype.indexOfRawIndex = function (rawIndex) {\n    if (rawIndex >= this._rawCount || rawIndex < 0) {\n      return -1;\n    }\n\n    if (!this._indices) {\n      return rawIndex;\n    } // Indices are ascending\n\n\n    var indices = this._indices; // If rawIndex === dataIndex\n\n    var rawDataIndex = indices[rawIndex];\n\n    if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n      return rawIndex;\n    }\n\n    var left = 0;\n    var right = this._count - 1;\n\n    while (left <= right) {\n      var mid = (left + right) / 2 | 0;\n\n      if (indices[mid] < rawIndex) {\n        left = mid + 1;\n      } else if (indices[mid] > rawIndex) {\n        right = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n\n    return -1;\n  };\n  /**\n   * Retreive the index of nearest value\n   * @param dim\n   * @param value\n   * @param [maxDistance=Infinity]\n   * @return If and only if multiple indices has\n   *         the same value, they are put to the result.\n   */\n\n\n  List.prototype.indicesOfNearest = function (dim, value, maxDistance) {\n    var storage = this._storage;\n    var dimData = storage[dim];\n    var nearestIndices = [];\n\n    if (!dimData) {\n      return nearestIndices;\n    }\n\n    if (maxDistance == null) {\n      maxDistance = Infinity;\n    }\n\n    var minDist = Infinity;\n    var minDiff = -1;\n    var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/List.js`.\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var dataIndex = this.getRawIndex(i);\n      var diff = value - dimData[dataIndex];\n      var dist = Math.abs(diff);\n\n      if (dist <= maxDistance) {\n        // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n        // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n        // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n        // So we chose the one that `diff >= 0` in this csae.\n        // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n        // should be push to `nearestIndices`.\n        if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n          minDist = dist;\n          minDiff = diff;\n          nearestIndicesLen = 0;\n        }\n\n        if (diff === minDiff) {\n          nearestIndices[nearestIndicesLen++] = i;\n        }\n      }\n    }\n\n    nearestIndices.length = nearestIndicesLen;\n    return nearestIndices;\n  };\n  /**\n   * Get raw data item\n   */\n\n\n  List.prototype.getRawDataItem = function (idx) {\n    if (!this._rawData.persistent) {\n      var val = [];\n\n      for (var i = 0; i < this.dimensions.length; i++) {\n        var dim = this.dimensions[i];\n        val.push(this.get(dim, idx));\n      }\n\n      return val;\n    } else {\n      return this._rawData.getItem(this.getRawIndex(idx));\n    }\n  };\n  /**\n   * @return Never be null/undefined. `number` will be converted to string. Becuase:\n   * In most cases, name is used in display, where returning a string is more convenient.\n   * In other cases, name is used in query (see `indexOfName`), where we can keep the\n   * rule that name `2` equals to name `'2'`.\n   */\n\n\n  List.prototype.getName = function (idx) {\n    var rawIndex = this.getRawIndex(idx);\n    var name = this._nameList[rawIndex];\n\n    if (name == null && this._nameDimIdx != null) {\n      name = getIdNameFromStore(this, this._nameDimIdx, this._nameOrdinalMeta, rawIndex);\n    }\n\n    if (name == null) {\n      name = '';\n    }\n\n    return name;\n  };\n  /**\n   * @return Never null/undefined. `number` will be converted to string. Becuase:\n   * In all cases having encountered at present, id is used in making diff comparison, which\n   * are usually based on hash map. We can keep the rule that the internal id are always string\n   * (treat `2` is the same as `'2'`) to make the related logic simple.\n   */\n\n\n  List.prototype.getId = function (idx) {\n    return getId(this, this.getRawIndex(idx));\n  };\n\n  List.prototype.each = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var _this = this;\n\n    if (!this._count) {\n      return;\n    }\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var dimSize = dimNames.length;\n    var dimIndices = map(dimNames, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var storageArr = this._storageArr;\n\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var rawIdx = this.getRawIndex(i); // Simple optimization\n\n      switch (dimSize) {\n        case 0:\n          cb.call(fCtx, i);\n          break;\n\n        case 1:\n          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], i);\n          break;\n\n        case 2:\n          cb.call(fCtx, storageArr[dimIndices[0]][rawIdx], storageArr[dimIndices[1]][rawIdx], i);\n          break;\n\n        default:\n          var k = 0;\n          var value = [];\n\n          for (; k < dimSize; k++) {\n            value[k] = storageArr[dimIndices[k]][rawIdx];\n          } // Index\n\n\n          value[k] = i;\n          cb.apply(fCtx, value);\n      }\n    }\n  };\n\n  List.prototype.filterSelf = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    var _this = this;\n\n    if (!this._count) {\n      return;\n    }\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var count = this.count();\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(count);\n    var value = [];\n    var dimSize = dimNames.length;\n    var offset = 0;\n    var dimIndices = map(dimNames, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var dim0 = dimIndices[0];\n    var storageArr = this._storageArr;\n\n    for (var i = 0; i < count; i++) {\n      var keep = void 0;\n      var rawIdx = this.getRawIndex(i); // Simple optimization\n\n      if (dimSize === 0) {\n        keep = cb.call(fCtx, i);\n      } else if (dimSize === 1) {\n        var val = storageArr[dim0][rawIdx];\n        keep = cb.call(fCtx, val, i);\n      } else {\n        var k = 0;\n\n        for (; k < dimSize; k++) {\n          value[k] = storageArr[dimIndices[k]][rawIdx];\n        }\n\n        value[k] = i;\n        keep = cb.apply(fCtx, value);\n      }\n\n      if (keep) {\n        newIndices[offset++] = rawIdx;\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < count) {\n      this._indices = newIndices;\n    }\n\n    this._count = offset; // Reset data extent\n\n    this._extent = {};\n    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return this;\n  };\n  /**\n   * Select data in range. (For optimization of filter)\n   * (Manually inline code, support 5 million data filtering in data zoom.)\n   */\n\n\n  List.prototype.selectRange = function (range) {\n    'use strict';\n\n    var _this = this;\n\n    var len = this._count;\n\n    if (!len) {\n      return;\n    }\n\n    var dimensions = [];\n\n    for (var dim in range) {\n      if (range.hasOwnProperty(dim)) {\n        dimensions.push(dim);\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimensions);\n    }\n\n    var dimSize = dimensions.length;\n\n    if (!dimSize) {\n      return;\n    }\n\n    var originalCount = this.count();\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(originalCount);\n    var offset = 0;\n    var dim0 = dimensions[0];\n    var dimIndices = map(dimensions, function (dimName) {\n      return _this._dimensionInfos[dimName].index;\n    });\n    var min = range[dim0][0];\n    var max = range[dim0][1];\n    var storageArr = this._storageArr;\n    var quickFinished = false;\n\n    if (!this._indices) {\n      // Extreme optimization for common case. About 2x faster in chrome.\n      var idx = 0;\n\n      if (dimSize === 1) {\n        var dimStorage = storageArr[dimIndices[0]];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      } else if (dimSize === 2) {\n        var dimStorage = storageArr[dimIndices[0]];\n        var dimStorage2 = storageArr[dimIndices[1]];\n        var min2 = range[dimensions[1]][0];\n        var max2 = range[dimensions[1]][1];\n\n        for (var i = 0; i < len; i++) {\n          var val = dimStorage[i];\n          var val2 = dimStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n\n        quickFinished = true;\n      }\n    }\n\n    if (!quickFinished) {\n      if (dimSize === 1) {\n        for (var i = 0; i < originalCount; i++) {\n          var rawIndex = this.getRawIndex(i);\n          var val = storageArr[dimIndices[0]][rawIndex]; // Do not filter NaN, see comment above.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = rawIndex;\n          }\n        }\n      } else {\n        for (var i = 0; i < originalCount; i++) {\n          var keep = true;\n          var rawIndex = this.getRawIndex(i);\n\n          for (var k = 0; k < dimSize; k++) {\n            var dimk = dimensions[k];\n            var val = storageArr[dimIndices[k]][rawIndex]; // Do not filter NaN, see comment above.\n\n            if (val < range[dimk][0] || val > range[dimk][1]) {\n              keep = false;\n            }\n          }\n\n          if (keep) {\n            newIndices[offset++] = this.getRawIndex(i);\n          }\n        }\n      }\n    } // Set indices after filtered.\n\n\n    if (offset < originalCount) {\n      this._indices = newIndices;\n    }\n\n    this._count = offset; // Reset data extent\n\n    this._extent = {};\n    this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return this;\n  };\n  /* eslint-enable */\n\n\n  List.prototype.mapArray = function (dims, cb, ctx, ctxCompat) {\n    'use strict';\n\n    if (typeof dims === 'function') {\n      ctxCompat = ctx;\n      ctx = cb;\n      cb = dims;\n      dims = [];\n    } // ctxCompat just for compat echarts3\n\n\n    ctx = ctx || ctxCompat || this;\n    var result = [];\n    this.each(dims, function () {\n      result.push(cb && cb.apply(this, arguments));\n    }, ctx);\n    return result;\n  };\n\n  List.prototype.map = function (dims, cb, ctx, ctxCompat) {\n    'use strict'; // ctxCompat just for compat echarts3\n\n    var fCtx = ctx || ctxCompat || this;\n    var dimNames = map(normalizeDimensions(dims), this.getDimension, this);\n\n    if (process.env.NODE_ENV !== 'production') {\n      validateDimensions(this, dimNames);\n    }\n\n    var list = cloneListForMapAndSample(this, dimNames);\n    var storage = list._storage; // Following properties are all immutable.\n    // So we can reference to the same value\n\n    list._indices = this._indices;\n    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    var tmpRetValue = [];\n    var dimSize = dimNames.length;\n    var dataCount = this.count();\n    var values = [];\n    var rawExtent = list._rawExtent;\n\n    for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n      for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n        values[dimIndex] = this.get(dimNames[dimIndex], dataIndex);\n      }\n\n      values[dimSize] = dataIndex;\n      var retValue = cb && cb.apply(fCtx, values);\n\n      if (retValue != null) {\n        // a number or string (in oridinal dimension)?\n        if (typeof retValue !== 'object') {\n          tmpRetValue[0] = retValue;\n          retValue = tmpRetValue;\n        }\n\n        var rawIndex = this.getRawIndex(dataIndex);\n\n        for (var i = 0; i < retValue.length; i++) {\n          var dim = dimNames[i];\n          var val = retValue[i];\n          var rawExtentOnDim = rawExtent[dim];\n          var dimStore = storage[dim];\n\n          if (dimStore) {\n            dimStore[rawIndex] = val;\n          }\n\n          if (val < rawExtentOnDim[0]) {\n            rawExtentOnDim[0] = val;\n          }\n\n          if (val > rawExtentOnDim[1]) {\n            rawExtentOnDim[1] = val;\n          }\n        }\n      }\n    }\n\n    return list;\n  };\n  /**\n   * Large data down sampling on given dimension\n   * @param sampleIndex Sample index for name and id\n   */\n\n\n  List.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n    var list = cloneListForMapAndSample(this, [dimension]);\n    var targetStorage = list._storage;\n    var frameValues = [];\n    var frameSize = mathFloor(1 / rate);\n    var dimStore = targetStorage[dimension];\n    var len = this.count();\n    var rawExtentOnDim = list._rawExtent[dimension];\n    var newIndices = new (getIndicesCtor(this))(len);\n    var offset = 0;\n\n    for (var i = 0; i < len; i += frameSize) {\n      // Last frame\n      if (frameSize > len - i) {\n        frameSize = len - i;\n        frameValues.length = frameSize;\n      }\n\n      for (var k = 0; k < frameSize; k++) {\n        var dataIdx = this.getRawIndex(i + k);\n        frameValues[k] = dimStore[dataIdx];\n      }\n\n      var value = sampleValue(frameValues);\n      var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)); // Only write value on the filtered data\n\n      dimStore[sampleFrameIdx] = value;\n\n      if (value < rawExtentOnDim[0]) {\n        rawExtentOnDim[0] = value;\n      }\n\n      if (value > rawExtentOnDim[1]) {\n        rawExtentOnDim[1] = value;\n      }\n\n      newIndices[offset++] = sampleFrameIdx;\n    }\n\n    list._count = offset;\n    list._indices = newIndices;\n    list.getRawIndex = getRawIndexWithIndices;\n    return list;\n  };\n  /**\n   * Large data down sampling using largest-triangle-three-buckets\n   * @param {string} valueDimension\n   * @param {number} targetCount\n   */\n\n\n  List.prototype.lttbDownSample = function (valueDimension, rate) {\n    var list = cloneListForMapAndSample(this, []);\n    var targetStorage = list._storage;\n    var dimStore = targetStorage[valueDimension];\n    var len = this.count();\n    var newIndices = new (getIndicesCtor(this))(len);\n    var sampledIndex = 0;\n    var frameSize = mathFloor(1 / rate);\n    var currentRawIndex = this.getRawIndex(0);\n    var maxArea;\n    var area;\n    var nextRawIndex; // First frame use the first data.\n\n    newIndices[sampledIndex++] = currentRawIndex;\n\n    for (var i = 1; i < len - 1; i += frameSize) {\n      var nextFrameStart = Math.min(i + frameSize, len - 1);\n      var nextFrameEnd = Math.min(i + frameSize * 2, len);\n      var avgX = (nextFrameEnd + nextFrameStart) / 2;\n      var avgY = 0;\n\n      for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        }\n\n        avgY += y;\n      }\n\n      avgY /= nextFrameEnd - nextFrameStart;\n      var frameStart = i;\n      var frameEnd = Math.min(i + frameSize, len);\n      var pointAX = i - 1;\n      var pointAY = dimStore[currentRawIndex];\n      maxArea = -1;\n      nextRawIndex = frameStart; // Find a point from current frame that construct a triangel with largest area with previous selected point\n      // And the average of next frame.\n\n      for (var idx = frameStart; idx < frameEnd; idx++) {\n        var rawIndex = this.getRawIndex(idx);\n        var y = dimStore[rawIndex];\n\n        if (isNaN(y)) {\n          continue;\n        } // Calculate triangle area over three buckets\n\n\n        area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY));\n\n        if (area > maxArea) {\n          maxArea = area;\n          nextRawIndex = rawIndex; // Next a is this b\n        }\n      }\n\n      newIndices[sampledIndex++] = nextRawIndex;\n      currentRawIndex = nextRawIndex; // This a is the next a (chosen b)\n    } // First frame use the last data.\n\n\n    newIndices[sampledIndex++] = this.getRawIndex(len - 1);\n    list._count = sampledIndex;\n    list._indices = newIndices;\n    list.getRawIndex = getRawIndexWithIndices;\n    return list;\n  };\n  /**\n   * Get model of one data item.\n   */\n  // TODO: Type of data item\n\n\n  List.prototype.getItemModel = function (idx) {\n    var hostModel = this.hostModel;\n    var dataItem = this.getRawDataItem(idx);\n    return new Model(dataItem, hostModel, hostModel && hostModel.ecModel);\n  };\n  /**\n   * Create a data differ\n   */\n\n\n  List.prototype.diff = function (otherList) {\n    var thisList = this;\n    return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n      return getId(otherList, idx);\n    }, function (idx) {\n      return getId(thisList, idx);\n    });\n  };\n  /**\n   * Get visual property.\n   */\n\n\n  List.prototype.getVisual = function (key) {\n    var visual = this._visual;\n    return visual && visual[key];\n  };\n\n  List.prototype.setVisual = function (kvObj, val) {\n    this._visual = this._visual || {};\n\n    if (isObject(kvObj)) {\n      zrUtil.extend(this._visual, kvObj);\n    } else {\n      this._visual[kvObj] = val;\n    }\n  };\n  /**\n   * Get visual property of single data item\n   */\n  // eslint-disable-next-line\n\n\n  List.prototype.getItemVisual = function (idx, key) {\n    var itemVisual = this._itemVisuals[idx];\n    var val = itemVisual && itemVisual[key];\n\n    if (val == null) {\n      // Use global visual property\n      return this.getVisual(key);\n    }\n\n    return val;\n  };\n  /**\n   * If exists visual property of single data item\n   */\n\n\n  List.prototype.hasItemVisual = function () {\n    return this._itemVisuals.length > 0;\n  };\n  /**\n   * Make sure itemVisual property is unique\n   */\n  // TODO: use key to save visual to reduce memory.\n\n\n  List.prototype.ensureUniqueItemVisual = function (idx, key) {\n    var itemVisuals = this._itemVisuals;\n    var itemVisual = itemVisuals[idx];\n\n    if (!itemVisual) {\n      itemVisual = itemVisuals[idx] = {};\n    }\n\n    var val = itemVisual[key];\n\n    if (val == null) {\n      val = this.getVisual(key); // TODO Performance?\n\n      if (zrUtil.isArray(val)) {\n        val = val.slice();\n      } else if (isObject(val)) {\n        val = zrUtil.extend({}, val);\n      }\n\n      itemVisual[key] = val;\n    }\n\n    return val;\n  }; // eslint-disable-next-line\n\n\n  List.prototype.setItemVisual = function (idx, key, value) {\n    var itemVisual = this._itemVisuals[idx] || {};\n    this._itemVisuals[idx] = itemVisual;\n\n    if (isObject(key)) {\n      zrUtil.extend(itemVisual, key);\n    } else {\n      itemVisual[key] = value;\n    }\n  };\n  /**\n   * Clear itemVisuals and list visual.\n   */\n\n\n  List.prototype.clearAllVisual = function () {\n    this._visual = {};\n    this._itemVisuals = [];\n  };\n\n  List.prototype.setLayout = function (key, val) {\n    if (isObject(key)) {\n      for (var name_1 in key) {\n        if (key.hasOwnProperty(name_1)) {\n          this.setLayout(name_1, key[name_1]);\n        }\n      }\n\n      return;\n    }\n\n    this._layout[key] = val;\n  };\n  /**\n   * Get layout property.\n   */\n\n\n  List.prototype.getLayout = function (key) {\n    return this._layout[key];\n  };\n  /**\n   * Get layout of single data item\n   */\n\n\n  List.prototype.getItemLayout = function (idx) {\n    return this._itemLayouts[idx];\n  };\n  /**\n   * Set layout of single data item\n   */\n\n\n  List.prototype.setItemLayout = function (idx, layout, merge) {\n    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n  };\n  /**\n   * Clear all layout of single data item\n   */\n\n\n  List.prototype.clearItemLayouts = function () {\n    this._itemLayouts.length = 0;\n  };\n  /**\n   * Set graphic element relative to data. It can be set as null\n   */\n\n\n  List.prototype.setItemGraphicEl = function (idx, el) {\n    var hostModel = this.hostModel;\n\n    if (el) {\n      var ecData = getECData(el); // Add data index and series index for indexing the data by element\n      // Useful in tooltip\n\n      ecData.dataIndex = idx;\n      ecData.dataType = this.dataType;\n      ecData.seriesIndex = hostModel && hostModel.seriesIndex; // TODO: not store dataIndex on children.\n\n      if (el.type === 'group') {\n        el.traverse(setItemDataAndSeriesIndex, el);\n      }\n    }\n\n    this._graphicEls[idx] = el;\n  };\n\n  List.prototype.getItemGraphicEl = function (idx) {\n    return this._graphicEls[idx];\n  };\n\n  List.prototype.eachItemGraphicEl = function (cb, context) {\n    zrUtil.each(this._graphicEls, function (el, idx) {\n      if (el) {\n        cb && cb.call(context, el, idx);\n      }\n    });\n  };\n  /**\n   * Shallow clone a new list except visual and layout properties, and graph elements.\n   * New list only change the indices.\n   */\n\n\n  List.prototype.cloneShallow = function (list) {\n    if (!list) {\n      var dimensionInfoList = map(this.dimensions, this.getDimensionInfo, this);\n      list = new List(dimensionInfoList, this.hostModel);\n    } // FIXME\n\n\n    list._storage = this._storage;\n    list._storageArr = this._storageArr;\n    transferProperties(list, this); // Clone will not change the data extent and indices\n\n    if (this._indices) {\n      var Ctor = this._indices.constructor;\n\n      if (Ctor === Array) {\n        var thisCount = this._indices.length;\n        list._indices = new Ctor(thisCount);\n\n        for (var i = 0; i < thisCount; i++) {\n          list._indices[i] = this._indices[i];\n        }\n      } else {\n        list._indices = new Ctor(this._indices);\n      }\n    } else {\n      list._indices = null;\n    }\n\n    list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n    return list;\n  };\n  /**\n   * Wrap some method to add more feature\n   */\n\n\n  List.prototype.wrapMethod = function (methodName, injectFunction) {\n    var originalMethod = this[methodName];\n\n    if (typeof originalMethod !== 'function') {\n      return;\n    }\n\n    this.__wrappedMethods = this.__wrappedMethods || [];\n\n    this.__wrappedMethods.push(methodName);\n\n    this[methodName] = function () {\n      var res = originalMethod.apply(this, arguments);\n      return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n    };\n  }; // ----------------------------------------------------------\n  // A work around for internal method visiting private member.\n  // ----------------------------------------------------------\n\n\n  List.internalField = function () {\n    defaultDimValueGetters = {\n      arrayRows: getDimValueSimply,\n      objectRows: function (dataItem, dimName, dataIndex, dimIndex) {\n        return parseDataValue(dataItem[dimName], this._dimensionInfos[dimName]);\n      },\n      keyedColumns: getDimValueSimply,\n      original: function (dataItem, dimName, dataIndex, dimIndex) {\n        // Performance sensitive, do not use modelUtil.getDataItemValue.\n        // If dataItem is an plain object with no value field, the let `value`\n        // will be assigned with the object, but it will be tread correctly\n        // in the `convertValue`.\n        var value = dataItem && (dataItem.value == null ? dataItem : dataItem.value); // If any dataItem is like { value: 10 }\n\n        if (!this._rawData.pure && isDataItemOption(dataItem)) {\n          this.hasItemOption = true;\n        }\n\n        return parseDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.\n        : value, this._dimensionInfos[dimName]);\n      },\n      typedArray: function (dataItem, dimName, dataIndex, dimIndex) {\n        return dataItem[dimIndex];\n      }\n    };\n\n    function getDimValueSimply(dataItem, dimName, dataIndex, dimIndex) {\n      return parseDataValue(dataItem[dimIndex], this._dimensionInfos[dimName]);\n    }\n\n    prepareInvertedIndex = function (list) {\n      var invertedIndicesMap = list._invertedIndicesMap;\n      zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n        var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n        var ordinalMeta = dimInfo.ordinalMeta;\n\n        if (ordinalMeta) {\n          invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n          // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n          for (var i = 0; i < invertedIndices.length; i++) {\n            invertedIndices[i] = INDEX_NOT_FOUND;\n          }\n\n          for (var i = 0; i < list._count; i++) {\n            // Only support the case that all values are distinct.\n            invertedIndices[list.get(dim, i)] = i;\n          }\n        }\n      });\n    };\n\n    getIdNameFromStore = function (list, dimIdx, ordinalMeta, rawIndex) {\n      var val;\n      var chunk = list._storageArr[dimIdx];\n\n      if (chunk) {\n        val = chunk[rawIndex];\n\n        if (ordinalMeta && ordinalMeta.categories.length) {\n          val = ordinalMeta.categories[val];\n        }\n      }\n\n      return convertOptionIdName(val, null);\n    };\n\n    getIndicesCtor = function (list) {\n      // The possible max value in this._indicies is always this._rawCount despite of filtering.\n      return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n    };\n\n    prepareStorage = function (storage, dimInfo, end, append) {\n      var DataCtor = dataCtors[dimInfo.type];\n      var dim = dimInfo.name;\n\n      if (append) {\n        var oldStore = storage[dim];\n        var oldLen = oldStore && oldStore.length;\n\n        if (!(oldLen === end)) {\n          var newStore = new DataCtor(end); // The cost of the copy is probably inconsiderable\n          // within the initial chunkSize.\n\n          for (var j = 0; j < oldLen; j++) {\n            newStore[j] = oldStore[j];\n          }\n\n          storage[dim] = newStore;\n        }\n      } else {\n        storage[dim] = new DataCtor(end);\n      }\n    };\n\n    getRawIndexWithoutIndices = function (idx) {\n      return idx;\n    };\n\n    getRawIndexWithIndices = function (idx) {\n      if (idx < this._count && idx >= 0) {\n        return this._indices[idx];\n      }\n\n      return -1;\n    };\n    /**\n     * @see the comment of `List['getId']`.\n     */\n\n\n    getId = function (list, rawIndex) {\n      var id = list._idList[rawIndex];\n\n      if (id == null && list._idDimIdx != null) {\n        id = getIdNameFromStore(list, list._idDimIdx, list._idOrdinalMeta, rawIndex);\n      }\n\n      if (id == null) {\n        id = ID_PREFIX + rawIndex;\n      }\n\n      return id;\n    };\n\n    normalizeDimensions = function (dimensions) {\n      if (!zrUtil.isArray(dimensions)) {\n        dimensions = dimensions != null ? [dimensions] : [];\n      }\n\n      return dimensions;\n    };\n\n    validateDimensions = function (list, dims) {\n      for (var i = 0; i < dims.length; i++) {\n        // stroage may be empty when no data, so use\n        // dimensionInfos to check.\n        if (!list._dimensionInfos[dims[i]]) {\n          console.error('Unkown dimension ' + dims[i]);\n        }\n      }\n    }; // Data in excludeDimensions is copied, otherwise transfered.\n\n\n    cloneListForMapAndSample = function (original, excludeDimensions) {\n      var allDimensions = original.dimensions;\n      var list = new List(map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n      transferProperties(list, original);\n      var storage = list._storage = {};\n      var originalStorage = original._storage;\n      var storageArr = list._storageArr = []; // Init storage\n\n      for (var i = 0; i < allDimensions.length; i++) {\n        var dim = allDimensions[i];\n\n        if (originalStorage[dim]) {\n          // Notice that we do not reset invertedIndicesMap here, becuase\n          // there is no scenario of mapping or sampling ordinal dimension.\n          if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n            storage[dim] = cloneChunk(originalStorage[dim]);\n            list._rawExtent[dim] = getInitialExtent();\n            list._extent[dim] = null;\n          } else {\n            // Direct reference for other dimensions\n            storage[dim] = originalStorage[dim];\n          }\n\n          storageArr.push(storage[dim]);\n        }\n      }\n\n      return list;\n    };\n\n    function cloneChunk(originalChunk) {\n      var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n      return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n    }\n\n    getInitialExtent = function () {\n      return [Infinity, -Infinity];\n    };\n\n    setItemDataAndSeriesIndex = function (child) {\n      var childECData = getECData(child);\n      var thisECData = getECData(this);\n      childECData.seriesIndex = thisECData.seriesIndex;\n      childECData.dataIndex = thisECData.dataIndex;\n      childECData.dataType = thisECData.dataType;\n    };\n\n    transferProperties = function (target, source) {\n      zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n        if (source.hasOwnProperty(propName)) {\n          target[propName] = source[propName];\n        }\n      });\n      target.__wrappedMethods = source.__wrappedMethods;\n      zrUtil.each(CLONE_PROPERTIES, function (propName) {\n        target[propName] = zrUtil.clone(source[propName]);\n      });\n      target._calculationInfo = zrUtil.extend({}, source._calculationInfo);\n    };\n\n    makeIdFromName = function (list, idx) {\n      var nameList = list._nameList;\n      var idList = list._idList;\n      var nameDimIdx = list._nameDimIdx;\n      var idDimIdx = list._idDimIdx;\n      var name = nameList[idx];\n      var id = idList[idx];\n\n      if (name == null && nameDimIdx != null) {\n        nameList[idx] = name = getIdNameFromStore(list, nameDimIdx, list._nameOrdinalMeta, idx);\n      }\n\n      if (id == null && idDimIdx != null) {\n        idList[idx] = id = getIdNameFromStore(list, idDimIdx, list._idOrdinalMeta, idx);\n      }\n\n      if (id == null && name != null) {\n        var nameRepeatCount = list._nameRepeatCount;\n        var nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1;\n        id = name;\n\n        if (nmCnt > 1) {\n          id += '__ec__' + nmCnt;\n        }\n\n        idList[idx] = id;\n      }\n    };\n  }();\n\n  return List;\n}();\n\nexport default List;"],"mappings":"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"},"metadata":{},"sourceType":"module"}