{"ast":null,"code":"import PathProxy from '../core/PathProxy';\nimport { cubicSubdivide } from '../core/curve';\nimport { defaults, assert, noop, clone } from '../core/util';\nimport { lerp } from '../core/vector';\nimport Rect from '../graphic/shape/Rect';\nimport Sector from '../graphic/shape/Sector';\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar PROP_XY = ['x', 'y'];\nvar PROP_WH = ['width', 'height'];\nvar tmpArr = [];\n\nfunction aroundEqual(a, b) {\n  return Math.abs(a - b) < 1e-5;\n}\n\nexport function pathToBezierCurves(path) {\n  var data = path.data;\n  var len = path.len();\n  var bezierArray = [];\n  var currentSubpath;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n\n  function createNewSubpath(x, y) {\n    if (currentSubpath && currentSubpath.length > 2) {\n      bezierArray.push(currentSubpath);\n    }\n\n    currentSubpath = [x, y];\n  }\n\n  function addLine(x0, y0, x1, y1) {\n    if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n      currentSubpath.push(x0, y0, x1, y1, x1, y1);\n    }\n  }\n\n  function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n    var delta = Math.abs(endAngle - startAngle);\n    var len = Math.tan(delta / 4) * 4 / 3;\n    var dir = endAngle < startAngle ? -1 : 1;\n    var c1 = Math.cos(startAngle);\n    var s1 = Math.sin(startAngle);\n    var c2 = Math.cos(endAngle);\n    var s2 = Math.sin(endAngle);\n    var x1 = c1 * rx + cx;\n    var y1 = s1 * ry + cy;\n    var x4 = c2 * rx + cx;\n    var y4 = s2 * ry + cy;\n    var hx = rx * len * dir;\n    var hy = ry * len * dir;\n    currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n  }\n\n  var x1;\n  var y1;\n  var x2;\n  var y2;\n\n  for (var i = 0; i < len;) {\n    var cmd = data[i++];\n    var isFirst = i === 1;\n\n    if (isFirst) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n\n      if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n        currentSubpath = [x0, y0];\n      }\n    }\n\n    switch (cmd) {\n      case CMD.M:\n        xi = x0 = data[i++];\n        yi = y0 = data[i++];\n        createNewSubpath(x0, y0);\n        break;\n\n      case CMD.L:\n        x1 = data[i++];\n        y1 = data[i++];\n        addLine(xi, yi, x1, y1);\n        xi = x1;\n        yi = y1;\n        break;\n\n      case CMD.C:\n        currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n        break;\n\n      case CMD.Q:\n        x1 = data[i++];\n        y1 = data[i++];\n        x2 = data[i++];\n        y2 = data[i++];\n        currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n        xi = x2;\n        yi = y2;\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var startAngle = data[i++];\n        var endAngle = data[i++] + startAngle;\n        i += 1;\n        var anticlockwise = !data[i++];\n        x1 = Math.cos(startAngle) * rx + cx;\n        y1 = Math.sin(startAngle) * ry + cy;\n\n        if (isFirst) {\n          x0 = x1;\n          y0 = y1;\n          createNewSubpath(x0, y0);\n        } else {\n          addLine(xi, yi, x1, y1);\n        }\n\n        xi = Math.cos(endAngle) * rx + cx;\n        yi = Math.sin(endAngle) * ry + cy;\n        var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n\n        for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n          var nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);\n          addArc(angle, nextAngle, cx, cy, rx, ry);\n        }\n\n        break;\n\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        x1 = x0 + data[i++];\n        y1 = y0 + data[i++];\n        createNewSubpath(x1, y0);\n        addLine(x1, y0, x1, y1);\n        addLine(x1, y1, x0, y1);\n        addLine(x0, y1, x0, y0);\n        addLine(x0, y0, x1, y0);\n        break;\n\n      case CMD.Z:\n        currentSubpath && addLine(xi, yi, x0, y0);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n\n  if (currentSubpath && currentSubpath.length > 2) {\n    bezierArray.push(currentSubpath);\n  }\n\n  return bezierArray;\n}\n\nfunction alignSubpath(subpath1, subpath2) {\n  var len1 = subpath1.length;\n  var len2 = subpath2.length;\n\n  if (len1 === len2) {\n    return [subpath1, subpath2];\n  }\n\n  var shorterPath = len1 < len2 ? subpath1 : subpath2;\n  var shorterLen = Math.min(len1, len2);\n  var diff = Math.abs(len2 - len1) / 6;\n  var shorterBezierCount = (shorterLen - 2) / 6;\n  var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n  var newSubpath = [shorterPath[0], shorterPath[1]];\n  var remained = diff;\n  var tmpSegX = [];\n  var tmpSegY = [];\n\n  for (var i = 2; i < shorterLen;) {\n    var x0 = shorterPath[i - 2];\n    var y0 = shorterPath[i - 1];\n    var x1 = shorterPath[i++];\n    var y1 = shorterPath[i++];\n    var x2 = shorterPath[i++];\n    var y2 = shorterPath[i++];\n    var x3 = shorterPath[i++];\n    var y3 = shorterPath[i++];\n\n    if (remained <= 0) {\n      newSubpath.push(x1, y1, x2, y2, x3, y3);\n      continue;\n    }\n\n    var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n\n    for (var k = 1; k <= actualSubDivCount; k++) {\n      var p = k / actualSubDivCount;\n      cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n      cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n      x0 = tmpSegX[3];\n      y0 = tmpSegY[3];\n      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n      x1 = tmpSegX[5];\n      y1 = tmpSegY[5];\n      x2 = tmpSegX[6];\n      y2 = tmpSegY[6];\n    }\n\n    remained -= actualSubDivCount - 1;\n  }\n\n  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\n\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n  var len = lastSubpathSubpath.length;\n  var lastX = lastSubpathSubpath[len - 2];\n  var lastY = lastSubpathSubpath[len - 1];\n  var newSubpath = [];\n\n  for (var i = 0; i < otherSubpath.length;) {\n    newSubpath[i++] = lastX;\n    newSubpath[i++] = lastY;\n  }\n\n  return newSubpath;\n}\n\nexport function alignBezierCurves(array1, array2) {\n  var _a;\n\n  var lastSubpath1;\n  var lastSubpath2;\n  var newArray1 = [];\n  var newArray2 = [];\n\n  for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n    var subpath1 = array1[i];\n    var subpath2 = array2[i];\n    var newSubpath1 = void 0;\n    var newSubpath2 = void 0;\n\n    if (!subpath1) {\n      newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n      newSubpath2 = subpath2;\n    } else if (!subpath2) {\n      newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n      newSubpath1 = subpath1;\n    } else {\n      _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n      lastSubpath1 = newSubpath1;\n      lastSubpath2 = newSubpath2;\n    }\n\n    newArray1.push(newSubpath1);\n    newArray2.push(newSubpath2);\n  }\n\n  return [newArray1, newArray2];\n}\nexport function centroid(array) {\n  var signedArea = 0;\n  var cx = 0;\n  var cy = 0;\n  var len = array.length;\n\n  for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n    var x0 = array[j];\n    var y0 = array[j + 1];\n    var x1 = array[i];\n    var y1 = array[i + 1];\n    var a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n  }\n\n  if (signedArea === 0) {\n    return [array[0] || 0, array[1] || 0];\n  }\n\n  return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\n\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n  var bezierCount = (fromSubBeziers.length - 2) / 6;\n  var bestScore = Infinity;\n  var bestOffset = 0;\n  var len = fromSubBeziers.length;\n  var len2 = len - 2;\n\n  for (var offset = 0; offset < bezierCount; offset++) {\n    var cursorOffset = offset * 6;\n    var score = 0;\n\n    for (var k = 0; k < len; k += 2) {\n      var idx = k === 0 ? cursorOffset : (cursorOffset + k - 2) % len2 + 2;\n      var x0 = fromSubBeziers[idx] - fromCp[0];\n      var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n      var x1 = toSubBeziers[k] - toCp[0];\n      var y1 = toSubBeziers[k + 1] - toCp[1];\n      var dx = x1 - x0;\n      var dy = y1 - y0;\n      score += dx * dx + dy * dy;\n    }\n\n    if (score < bestScore) {\n      bestScore = score;\n      bestOffset = offset;\n    }\n  }\n\n  return bestOffset;\n}\n\nfunction reverse(array) {\n  var newArr = [];\n  var len = array.length;\n\n  for (var i = 0; i < len; i += 2) {\n    newArr[i] = array[len - i - 2];\n    newArr[i + 1] = array[len - i - 1];\n  }\n\n  return newArr;\n}\n\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n  var result = [];\n  var fromNeedsReverse;\n\n  for (var i = 0; i < fromArr.length; i++) {\n    var fromSubpathBezier = fromArr[i];\n    var toSubpathBezier = toArr[i];\n    var fromCp = centroid(fromSubpathBezier);\n    var toCp = centroid(toSubpathBezier);\n\n    if (fromNeedsReverse == null) {\n      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n    }\n\n    var newFromSubpathBezier = [];\n    var newToSubpathBezier = [];\n    var bestAngle = 0;\n    var bestScore = Infinity;\n    var tmpArr_1 = [];\n    var len = fromSubpathBezier.length;\n\n    if (fromNeedsReverse) {\n      fromSubpathBezier = reverse(fromSubpathBezier);\n    }\n\n    var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n    var len2 = len - 2;\n\n    for (var k = 0; k < len2; k += 2) {\n      var idx = (offset + k) % len2 + 2;\n      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n      newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n    }\n\n    newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n    newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n\n    if (searchAngleIteration > 0) {\n      var step = searchAngleRange / searchAngleIteration;\n\n      for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        var score = 0;\n\n        for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n          var x0 = newFromSubpathBezier[k];\n          var y0 = newFromSubpathBezier[k + 1];\n          var x1 = toSubpathBezier[k] - toCp[0];\n          var y1 = toSubpathBezier[k + 1] - toCp[1];\n          var newX1 = x1 * ca - y1 * sa;\n          var newY1 = x1 * sa + y1 * ca;\n          tmpArr_1[k] = newX1;\n          tmpArr_1[k + 1] = newY1;\n          var dx = newX1 - x0;\n          var dy = newY1 - y0;\n          score += dx * dx + dy * dy;\n        }\n\n        if (score < bestScore) {\n          bestScore = score;\n          bestAngle = angle;\n\n          for (var m = 0; m < tmpArr_1.length; m++) {\n            newToSubpathBezier[m] = tmpArr_1[m];\n          }\n        }\n      }\n    } else {\n      for (var i_1 = 0; i_1 < len; i_1 += 2) {\n        newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n        newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n      }\n    }\n\n    result.push({\n      from: newFromSubpathBezier,\n      to: newToSubpathBezier,\n      fromCp: fromCp,\n      toCp: toCp,\n      rotation: -bestAngle\n    });\n  }\n\n  return result;\n}\n\nexport function morphPath(fromPath, toPath, animationOpts) {\n  var fromPathProxy;\n  var toPathProxy;\n\n  if (!fromPath || !toPath) {\n    return toPath;\n  }\n\n  !fromPath.path && fromPath.createPathProxy();\n  fromPathProxy = fromPath.path;\n  fromPathProxy.beginPath();\n  fromPath.buildPath(fromPathProxy, fromPath.shape);\n  !toPath.path && toPath.createPathProxy();\n  toPathProxy = toPath.path;\n  toPathProxy === fromPathProxy && (toPathProxy = new PathProxy(false));\n  toPathProxy.beginPath();\n\n  if (isIndividualMorphingPath(toPath)) {\n    toPath.__oldBuildPath(toPathProxy, toPath.shape);\n  } else {\n    toPath.buildPath(toPathProxy, toPath.shape);\n  }\n\n  var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)),\n      fromBezierCurves = _a[0],\n      toBezierCurves = _a[1];\n\n  var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n  becomeIndividualMorphingPath(toPath, morphingData, 0);\n  var oldDone = animationOpts && animationOpts.done;\n  var oldAborted = animationOpts && animationOpts.aborted;\n  var oldDuring = animationOpts && animationOpts.during;\n  toPath.animateTo({\n    __morphT: 1\n  }, defaults({\n    during: function (p) {\n      toPath.dirtyShape();\n      oldDuring && oldDuring(p);\n    },\n    done: function () {\n      restoreIndividualMorphingPath(toPath);\n      toPath.createPathProxy();\n      toPath.dirtyShape();\n      oldDone && oldDone();\n    },\n    aborted: function () {\n      oldAborted && oldAborted();\n    }\n  }, animationOpts));\n  return toPath;\n}\n\nfunction morphingPathBuildPath(path) {\n  var morphingData = this.__morphingData;\n  var t = this.__morphT;\n  var onet = 1 - t;\n  var newCp = [];\n\n  for (var i = 0; i < morphingData.length; i++) {\n    var item = morphingData[i];\n    var from = item.from;\n    var to = item.to;\n    var angle = item.rotation * t;\n    var fromCp = item.fromCp;\n    var toCp = item.toCp;\n    var sa = Math.sin(angle);\n    var ca = Math.cos(angle);\n    lerp(newCp, fromCp, toCp, t);\n\n    for (var m = 0; m < from.length; m += 2) {\n      var x0 = from[m];\n      var y0 = from[m + 1];\n      var x1 = to[m];\n      var y1 = to[m + 1];\n      var x = x0 * onet + x1 * t;\n      var y = y0 * onet + y1 * t;\n      tmpArr[m] = x * ca - y * sa + newCp[0];\n      tmpArr[m + 1] = x * sa + y * ca + newCp[1];\n    }\n\n    for (var m = 0; m < from.length;) {\n      if (m === 0) {\n        path.moveTo(tmpArr[m++], tmpArr[m++]);\n      }\n\n      path.bezierCurveTo(tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++]);\n    }\n  }\n}\n\n;\n\nfunction becomeIndividualMorphingPath(path, morphingData, morphT) {\n  if (isIndividualMorphingPath(path)) {\n    updateIndividualMorphingPath(path, morphingData, morphT);\n    return;\n  }\n\n  var morphingPath = path;\n  morphingPath.__oldBuildPath = morphingPath.buildPath;\n  morphingPath.buildPath = morphingPathBuildPath;\n  updateIndividualMorphingPath(morphingPath, morphingData, morphT);\n}\n\nfunction updateIndividualMorphingPath(morphingPath, morphingData, morphT) {\n  morphingPath.__morphingData = morphingData;\n  morphingPath.__morphT = morphT;\n}\n\nfunction restoreIndividualMorphingPath(path) {\n  if (isIndividualMorphingPath(path)) {\n    path.buildPath = path.__oldBuildPath;\n    path.__oldBuildPath = path.__morphingData = null;\n  }\n}\n\nfunction isIndividualMorphingPath(path) {\n  return path.__oldBuildPath != null;\n}\n\nexport function isCombiningPath(path) {\n  return !!path.__combiningSubList;\n}\nexport function isInAnyMorphing(path) {\n  return isIndividualMorphingPath(path) || isCombiningPath(path);\n}\nexport function combine(fromPathList, toPath, animationOpts, copyPropsIfDivided) {\n  var fromIndividuals = [];\n  var separateCount = 0;\n\n  for (var i = 0; i < fromPathList.length; i++) {\n    var fromPath = fromPathList[i];\n\n    if (isCombiningPath(fromPath)) {\n      var fromCombiningSubList = fromPath.__combiningSubList;\n\n      for (var j = 0; j < fromCombiningSubList.length; j++) {\n        fromIndividuals.push(fromCombiningSubList[j]);\n      }\n\n      separateCount += fromCombiningSubList.length;\n    } else {\n      fromIndividuals.push(fromPath);\n      separateCount++;\n    }\n  }\n\n  if (!separateCount) {\n    return;\n  }\n\n  var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n  var toPathSplittedList = divideShape(toPath, separateCount, dividingMethod);\n  assert(toPathSplittedList.length === separateCount);\n  var oldDone = animationOpts && animationOpts.done;\n  var oldAborted = animationOpts && animationOpts.aborted;\n  var oldDuring = animationOpts && animationOpts.during;\n  var doneCount = 0;\n  var abortedCalled = false;\n  var morphAnimationOpts = defaults({\n    during: function (p) {\n      oldDuring && oldDuring(p);\n    },\n    done: function () {\n      doneCount++;\n\n      if (doneCount === toPathSplittedList.length) {\n        restoreCombiningPath(toPath);\n        oldDone && oldDone();\n      }\n    },\n    aborted: function () {\n      if (!abortedCalled) {\n        abortedCalled = true;\n        oldAborted && oldAborted();\n      }\n    }\n  }, animationOpts);\n\n  for (var i = 0; i < separateCount; i++) {\n    var from = fromIndividuals[i];\n    var to = toPathSplittedList[i];\n    copyPropsIfDivided && copyPropsIfDivided(toPath, to, true);\n    morphPath(from, to, morphAnimationOpts);\n  }\n\n  becomeCombiningPath(toPath, toPathSplittedList);\n  return {\n    fromIndividuals: fromIndividuals,\n    toIndividuals: toPathSplittedList,\n    count: separateCount\n  };\n}\n\nfunction becomeCombiningPath(path, combiningSubList) {\n  if (isCombiningPath(path)) {\n    updateCombiningPathSubList(path, combiningSubList);\n    return;\n  }\n\n  var combiningPath = path;\n  updateCombiningPathSubList(combiningPath, combiningSubList);\n  combiningPath.__oldAddSelfToZr = path.addSelfToZr;\n  combiningPath.__oldRemoveSelfFromZr = path.removeSelfFromZr;\n  combiningPath.addSelfToZr = combiningAddSelfToZr;\n  combiningPath.removeSelfFromZr = combiningRemoveSelfFromZr;\n  combiningPath.__oldBuildPath = combiningPath.buildPath;\n  combiningPath.buildPath = noop;\n  combiningPath.childrenRef = combiningChildrenRef;\n}\n\nfunction restoreCombiningPath(path) {\n  if (!isCombiningPath(path)) {\n    return;\n  }\n\n  var combiningPath = path;\n  updateCombiningPathSubList(combiningPath, null);\n  combiningPath.addSelfToZr = combiningPath.__oldAddSelfToZr;\n  combiningPath.removeSelfFromZr = combiningPath.__oldRemoveSelfFromZr;\n  combiningPath.buildPath = combiningPath.__oldBuildPath;\n  combiningPath.childrenRef = combiningPath.__combiningSubList = combiningPath.__oldAddSelfToZr = combiningPath.__oldRemoveSelfFromZr = combiningPath.__oldBuildPath = null;\n}\n\nfunction updateCombiningPathSubList(combiningPath, combiningSubList) {\n  if (combiningPath.__combiningSubList !== combiningSubList) {\n    combiningPathSubListAddRemoveWithZr(combiningPath, 'removeSelfFromZr');\n    combiningPath.__combiningSubList = combiningSubList;\n\n    if (combiningSubList) {\n      for (var i = 0; i < combiningSubList.length; i++) {\n        combiningSubList[i].parent = combiningPath;\n      }\n    }\n\n    combiningPathSubListAddRemoveWithZr(combiningPath, 'addSelfToZr');\n  }\n}\n\nfunction combiningAddSelfToZr(zr) {\n  this.__oldAddSelfToZr(zr);\n\n  combiningPathSubListAddRemoveWithZr(this, 'addSelfToZr');\n}\n\nfunction combiningPathSubListAddRemoveWithZr(path, method) {\n  var combiningSubList = path.__combiningSubList;\n  var zr = path.__zr;\n\n  if (combiningSubList && zr) {\n    for (var i = 0; i < combiningSubList.length; i++) {\n      var child = combiningSubList[i];\n      child[method](zr);\n    }\n  }\n}\n\nfunction combiningRemoveSelfFromZr(zr) {\n  this.__oldRemoveSelfFromZr(zr);\n\n  var combiningSubList = this.__combiningSubList;\n\n  for (var i = 0; i < combiningSubList.length; i++) {\n    var child = combiningSubList[i];\n    child.removeSelfFromZr(zr);\n  }\n}\n\nfunction combiningChildrenRef() {\n  return this.__combiningSubList;\n}\n\nexport function separate(fromPath, toPathList, animationOpts, copyPropsIfDivided) {\n  var toPathListLen = toPathList.length;\n  var fromPathList;\n  var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n  var copyProps = false;\n\n  if (isCombiningPath(fromPath)) {\n    var fromCombiningSubList = fromPath.__combiningSubList;\n\n    if (fromCombiningSubList.length === toPathListLen) {\n      fromPathList = fromCombiningSubList;\n    } else {\n      fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n      copyProps = true;\n    }\n  } else {\n    fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n    copyProps = true;\n  }\n\n  assert(fromPathList.length === toPathListLen);\n\n  for (var i = 0; i < toPathListLen; i++) {\n    if (copyProps && copyPropsIfDivided) {\n      copyPropsIfDivided(fromPath, fromPathList[i], false);\n    }\n\n    morphPath(fromPathList[i], toPathList[i], animationOpts);\n  }\n\n  return {\n    fromIndividuals: fromPathList,\n    toIndividuals: toPathList,\n    count: toPathListLen\n  };\n}\n\nfunction divideShape(path, separateCount, dividingMethod) {\n  return dividingMethod === 'duplicate' ? duplicateShape(path, separateCount) : splitShape(path, separateCount);\n}\n\nfunction splitShape(path, separateCount) {\n  var resultPaths = [];\n\n  if (separateCount <= 0) {\n    return resultPaths;\n  }\n\n  if (separateCount === 1) {\n    return duplicateShape(path, separateCount);\n  }\n\n  if (path instanceof Rect) {\n    var toPathShape = path.shape;\n    var splitPropIdx = toPathShape.height > toPathShape.width ? 1 : 0;\n    var propWH = PROP_WH[splitPropIdx];\n    var propXY = PROP_XY[splitPropIdx];\n    var subWH = toPathShape[propWH] / separateCount;\n    var xyCurr = toPathShape[propXY];\n\n    for (var i = 0; i < separateCount; i++, xyCurr += subWH) {\n      var subShape = {\n        x: toPathShape.x,\n        y: toPathShape.y,\n        width: toPathShape.width,\n        height: toPathShape.height\n      };\n      subShape[propXY] = xyCurr;\n      subShape[propWH] = i < separateCount - 1 ? subWH : toPathShape[propXY] + toPathShape[propWH] - xyCurr;\n      var splitted = new Rect({\n        shape: subShape\n      });\n      resultPaths.push(splitted);\n    }\n  } else if (path instanceof Sector) {\n    var toPathShape = path.shape;\n    var clockwise = toPathShape.clockwise;\n    var startAngle = toPathShape.startAngle;\n    var endAngle = toPathShape.endAngle;\n    var endAngleNormalized = normalizeRadian(startAngle, toPathShape.endAngle, clockwise);\n    var step = (endAngleNormalized - startAngle) / separateCount;\n    var angleCurr = startAngle;\n\n    for (var i = 0; i < separateCount; i++, angleCurr += step) {\n      var splitted = new Sector({\n        shape: {\n          cx: toPathShape.cx,\n          cy: toPathShape.cy,\n          r: toPathShape.r,\n          r0: toPathShape.r0,\n          clockwise: clockwise,\n          startAngle: angleCurr,\n          endAngle: i === separateCount - 1 ? endAngle : angleCurr + step\n        }\n      });\n      resultPaths.push(splitted);\n    }\n  } else {\n    return duplicateShape(path, separateCount);\n  }\n\n  return resultPaths;\n}\n\nfunction duplicateShape(path, separateCount) {\n  var resultPaths = [];\n\n  if (separateCount <= 0) {\n    return resultPaths;\n  }\n\n  var ctor = path.constructor;\n\n  for (var i = 0; i < separateCount; i++) {\n    var sub = new ctor({\n      shape: clone(path.shape)\n    });\n    resultPaths.push(sub);\n  }\n\n  return resultPaths;\n}\n\nfunction normalizeRadian(start, end, clockwise) {\n  return end + PI2 * Math[clockwise ? 'ceil' : 'floor']((start - end) / PI2);\n}","map":{"version":3,"names":["PathProxy","cubicSubdivide","defaults","assert","noop","clone","lerp","Rect","Sector","CMD","PI2","Math","PI","PROP_XY","PROP_WH","tmpArr","aroundEqual","a","b","abs","pathToBezierCurves","path","data","len","bezierArray","currentSubpath","xi","yi","x0","y0","createNewSubpath","x","y","length","push","addLine","x1","y1","addArc","startAngle","endAngle","cx","cy","rx","ry","delta","tan","dir","c1","cos","s1","sin","c2","s2","x4","y4","hx","hy","x2","y2","i","cmd","isFirst","L","C","Q","M","A","anticlockwise","step","angle","nextAngle","max","min","R","Z","alignSubpath","subpath1","subpath2","len1","len2","shorterPath","shorterLen","diff","shorterBezierCount","eachCurveSubDivCount","ceil","newSubpath","remained","tmpSegX","tmpSegY","x3","y3","actualSubDivCount","k","p","createSubpath","lastSubpathSubpath","otherSubpath","lastX","lastY","alignBezierCurves","array1","array2","_a","lastSubpath1","lastSubpath2","newArray1","newArray2","newSubpath1","newSubpath2","centroid","array","signedArea","j","findBestRingOffset","fromSubBeziers","toSubBeziers","fromCp","toCp","bezierCount","bestScore","Infinity","bestOffset","offset","cursorOffset","score","idx","dx","dy","reverse","newArr","findBestMorphingRotation","fromArr","toArr","searchAngleIteration","searchAngleRange","result","fromNeedsReverse","fromSubpathBezier","toSubpathBezier","newFromSubpathBezier","newToSubpathBezier","bestAngle","tmpArr_1","sa","ca","newX1","newY1","m","i_1","from","to","rotation","morphPath","fromPath","toPath","animationOpts","fromPathProxy","toPathProxy","createPathProxy","beginPath","buildPath","shape","isIndividualMorphingPath","__oldBuildPath","fromBezierCurves","toBezierCurves","morphingData","becomeIndividualMorphingPath","oldDone","done","oldAborted","aborted","oldDuring","during","animateTo","__morphT","dirtyShape","restoreIndividualMorphingPath","morphingPathBuildPath","__morphingData","t","onet","newCp","item","moveTo","bezierCurveTo","morphT","updateIndividualMorphingPath","morphingPath","isCombiningPath","__combiningSubList","isInAnyMorphing","combine","fromPathList","copyPropsIfDivided","fromIndividuals","separateCount","fromCombiningSubList","dividingMethod","toPathSplittedList","divideShape","doneCount","abortedCalled","morphAnimationOpts","restoreCombiningPath","becomeCombiningPath","toIndividuals","count","combiningSubList","updateCombiningPathSubList","combiningPath","__oldAddSelfToZr","addSelfToZr","__oldRemoveSelfFromZr","removeSelfFromZr","combiningAddSelfToZr","combiningRemoveSelfFromZr","childrenRef","combiningChildrenRef","combiningPathSubListAddRemoveWithZr","parent","zr","method","__zr","child","separate","toPathList","toPathListLen","copyProps","duplicateShape","splitShape","resultPaths","toPathShape","splitPropIdx","height","width","propWH","propXY","subWH","xyCurr","subShape","splitted","clockwise","endAngleNormalized","normalizeRadian","angleCurr","r","r0","ctor","constructor","sub","start","end"],"sources":["E:/school/qianduan/web/vue-manage/node_modules/zrender/lib/tool/morphPath.js"],"sourcesContent":["import PathProxy from '../core/PathProxy';\nimport { cubicSubdivide } from '../core/curve';\nimport { defaults, assert, noop, clone } from '../core/util';\nimport { lerp } from '../core/vector';\nimport Rect from '../graphic/shape/Rect';\nimport Sector from '../graphic/shape/Sector';\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar PROP_XY = ['x', 'y'];\nvar PROP_WH = ['width', 'height'];\nvar tmpArr = [];\nfunction aroundEqual(a, b) {\n    return Math.abs(a - b) < 1e-5;\n}\nexport function pathToBezierCurves(path) {\n    var data = path.data;\n    var len = path.len();\n    var bezierArray = [];\n    var currentSubpath;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n    function createNewSubpath(x, y) {\n        if (currentSubpath && currentSubpath.length > 2) {\n            bezierArray.push(currentSubpath);\n        }\n        currentSubpath = [x, y];\n    }\n    function addLine(x0, y0, x1, y1) {\n        if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n            currentSubpath.push(x0, y0, x1, y1, x1, y1);\n        }\n    }\n    function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n        var delta = Math.abs(endAngle - startAngle);\n        var len = Math.tan(delta / 4) * 4 / 3;\n        var dir = endAngle < startAngle ? -1 : 1;\n        var c1 = Math.cos(startAngle);\n        var s1 = Math.sin(startAngle);\n        var c2 = Math.cos(endAngle);\n        var s2 = Math.sin(endAngle);\n        var x1 = c1 * rx + cx;\n        var y1 = s1 * ry + cy;\n        var x4 = c2 * rx + cx;\n        var y4 = s2 * ry + cy;\n        var hx = rx * len * dir;\n        var hy = ry * len * dir;\n        currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n    }\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    for (var i = 0; i < len;) {\n        var cmd = data[i++];\n        var isFirst = i === 1;\n        if (isFirst) {\n            xi = data[i];\n            yi = data[i + 1];\n            x0 = xi;\n            y0 = yi;\n            if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n                currentSubpath = [x0, y0];\n            }\n        }\n        switch (cmd) {\n            case CMD.M:\n                xi = x0 = data[i++];\n                yi = y0 = data[i++];\n                createNewSubpath(x0, y0);\n                break;\n            case CMD.L:\n                x1 = data[i++];\n                y1 = data[i++];\n                addLine(xi, yi, x1, y1);\n                xi = x1;\n                yi = y1;\n                break;\n            case CMD.C:\n                currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n                break;\n            case CMD.Q:\n                x1 = data[i++];\n                y1 = data[i++];\n                x2 = data[i++];\n                y2 = data[i++];\n                currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n                xi = x2;\n                yi = y2;\n                break;\n            case CMD.A:\n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var startAngle = data[i++];\n                var endAngle = data[i++] + startAngle;\n                i += 1;\n                var anticlockwise = !data[i++];\n                x1 = Math.cos(startAngle) * rx + cx;\n                y1 = Math.sin(startAngle) * ry + cy;\n                if (isFirst) {\n                    x0 = x1;\n                    y0 = y1;\n                    createNewSubpath(x0, y0);\n                }\n                else {\n                    addLine(xi, yi, x1, y1);\n                }\n                xi = Math.cos(endAngle) * rx + cx;\n                yi = Math.sin(endAngle) * ry + cy;\n                var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n                for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n                    var nextAngle = anticlockwise ? Math.max(angle + step, endAngle)\n                        : Math.min(angle + step, endAngle);\n                    addArc(angle, nextAngle, cx, cy, rx, ry);\n                }\n                break;\n            case CMD.R:\n                x0 = xi = data[i++];\n                y0 = yi = data[i++];\n                x1 = x0 + data[i++];\n                y1 = y0 + data[i++];\n                createNewSubpath(x1, y0);\n                addLine(x1, y0, x1, y1);\n                addLine(x1, y1, x0, y1);\n                addLine(x0, y1, x0, y0);\n                addLine(x0, y0, x1, y0);\n                break;\n            case CMD.Z:\n                currentSubpath && addLine(xi, yi, x0, y0);\n                xi = x0;\n                yi = y0;\n                break;\n        }\n    }\n    if (currentSubpath && currentSubpath.length > 2) {\n        bezierArray.push(currentSubpath);\n    }\n    return bezierArray;\n}\nfunction alignSubpath(subpath1, subpath2) {\n    var len1 = subpath1.length;\n    var len2 = subpath2.length;\n    if (len1 === len2) {\n        return [subpath1, subpath2];\n    }\n    var shorterPath = len1 < len2 ? subpath1 : subpath2;\n    var shorterLen = Math.min(len1, len2);\n    var diff = Math.abs(len2 - len1) / 6;\n    var shorterBezierCount = (shorterLen - 2) / 6;\n    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n    var newSubpath = [shorterPath[0], shorterPath[1]];\n    var remained = diff;\n    var tmpSegX = [];\n    var tmpSegY = [];\n    for (var i = 2; i < shorterLen;) {\n        var x0 = shorterPath[i - 2];\n        var y0 = shorterPath[i - 1];\n        var x1 = shorterPath[i++];\n        var y1 = shorterPath[i++];\n        var x2 = shorterPath[i++];\n        var y2 = shorterPath[i++];\n        var x3 = shorterPath[i++];\n        var y3 = shorterPath[i++];\n        if (remained <= 0) {\n            newSubpath.push(x1, y1, x2, y2, x3, y3);\n            continue;\n        }\n        var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n        for (var k = 1; k <= actualSubDivCount; k++) {\n            var p = k / actualSubDivCount;\n            cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n            cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n            x0 = tmpSegX[3];\n            y0 = tmpSegY[3];\n            newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n            x1 = tmpSegX[5];\n            y1 = tmpSegY[5];\n            x2 = tmpSegX[6];\n            y2 = tmpSegY[6];\n        }\n        remained -= actualSubDivCount - 1;\n    }\n    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n    var len = lastSubpathSubpath.length;\n    var lastX = lastSubpathSubpath[len - 2];\n    var lastY = lastSubpathSubpath[len - 1];\n    var newSubpath = [];\n    for (var i = 0; i < otherSubpath.length;) {\n        newSubpath[i++] = lastX;\n        newSubpath[i++] = lastY;\n    }\n    return newSubpath;\n}\nexport function alignBezierCurves(array1, array2) {\n    var _a;\n    var lastSubpath1;\n    var lastSubpath2;\n    var newArray1 = [];\n    var newArray2 = [];\n    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n        var subpath1 = array1[i];\n        var subpath2 = array2[i];\n        var newSubpath1 = void 0;\n        var newSubpath2 = void 0;\n        if (!subpath1) {\n            newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n            newSubpath2 = subpath2;\n        }\n        else if (!subpath2) {\n            newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n            newSubpath1 = subpath1;\n        }\n        else {\n            _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n            lastSubpath1 = newSubpath1;\n            lastSubpath2 = newSubpath2;\n        }\n        newArray1.push(newSubpath1);\n        newArray2.push(newSubpath2);\n    }\n    return [newArray1, newArray2];\n}\nexport function centroid(array) {\n    var signedArea = 0;\n    var cx = 0;\n    var cy = 0;\n    var len = array.length;\n    for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n        var x0 = array[j];\n        var y0 = array[j + 1];\n        var x1 = array[i];\n        var y1 = array[i + 1];\n        var a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n    }\n    if (signedArea === 0) {\n        return [array[0] || 0, array[1] || 0];\n    }\n    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n    var bezierCount = (fromSubBeziers.length - 2) / 6;\n    var bestScore = Infinity;\n    var bestOffset = 0;\n    var len = fromSubBeziers.length;\n    var len2 = len - 2;\n    for (var offset = 0; offset < bezierCount; offset++) {\n        var cursorOffset = offset * 6;\n        var score = 0;\n        for (var k = 0; k < len; k += 2) {\n            var idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2);\n            var x0 = fromSubBeziers[idx] - fromCp[0];\n            var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n            var x1 = toSubBeziers[k] - toCp[0];\n            var y1 = toSubBeziers[k + 1] - toCp[1];\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            score += dx * dx + dy * dy;\n        }\n        if (score < bestScore) {\n            bestScore = score;\n            bestOffset = offset;\n        }\n    }\n    return bestOffset;\n}\nfunction reverse(array) {\n    var newArr = [];\n    var len = array.length;\n    for (var i = 0; i < len; i += 2) {\n        newArr[i] = array[len - i - 2];\n        newArr[i + 1] = array[len - i - 1];\n    }\n    return newArr;\n}\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n    var result = [];\n    var fromNeedsReverse;\n    for (var i = 0; i < fromArr.length; i++) {\n        var fromSubpathBezier = fromArr[i];\n        var toSubpathBezier = toArr[i];\n        var fromCp = centroid(fromSubpathBezier);\n        var toCp = centroid(toSubpathBezier);\n        if (fromNeedsReverse == null) {\n            fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n        }\n        var newFromSubpathBezier = [];\n        var newToSubpathBezier = [];\n        var bestAngle = 0;\n        var bestScore = Infinity;\n        var tmpArr_1 = [];\n        var len = fromSubpathBezier.length;\n        if (fromNeedsReverse) {\n            fromSubpathBezier = reverse(fromSubpathBezier);\n        }\n        var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n        var len2 = len - 2;\n        for (var k = 0; k < len2; k += 2) {\n            var idx = (offset + k) % len2 + 2;\n            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n            newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n        }\n        newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n        newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n        if (searchAngleIteration > 0) {\n            var step = searchAngleRange / searchAngleIteration;\n            for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                var score = 0;\n                for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n                    var x0 = newFromSubpathBezier[k];\n                    var y0 = newFromSubpathBezier[k + 1];\n                    var x1 = toSubpathBezier[k] - toCp[0];\n                    var y1 = toSubpathBezier[k + 1] - toCp[1];\n                    var newX1 = x1 * ca - y1 * sa;\n                    var newY1 = x1 * sa + y1 * ca;\n                    tmpArr_1[k] = newX1;\n                    tmpArr_1[k + 1] = newY1;\n                    var dx = newX1 - x0;\n                    var dy = newY1 - y0;\n                    score += dx * dx + dy * dy;\n                }\n                if (score < bestScore) {\n                    bestScore = score;\n                    bestAngle = angle;\n                    for (var m = 0; m < tmpArr_1.length; m++) {\n                        newToSubpathBezier[m] = tmpArr_1[m];\n                    }\n                }\n            }\n        }\n        else {\n            for (var i_1 = 0; i_1 < len; i_1 += 2) {\n                newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n                newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n            }\n        }\n        result.push({\n            from: newFromSubpathBezier,\n            to: newToSubpathBezier,\n            fromCp: fromCp,\n            toCp: toCp,\n            rotation: -bestAngle\n        });\n    }\n    return result;\n}\nexport function morphPath(fromPath, toPath, animationOpts) {\n    var fromPathProxy;\n    var toPathProxy;\n    if (!fromPath || !toPath) {\n        return toPath;\n    }\n    !fromPath.path && fromPath.createPathProxy();\n    fromPathProxy = fromPath.path;\n    fromPathProxy.beginPath();\n    fromPath.buildPath(fromPathProxy, fromPath.shape);\n    !toPath.path && toPath.createPathProxy();\n    toPathProxy = toPath.path;\n    toPathProxy === fromPathProxy && (toPathProxy = new PathProxy(false));\n    toPathProxy.beginPath();\n    if (isIndividualMorphingPath(toPath)) {\n        toPath.__oldBuildPath(toPathProxy, toPath.shape);\n    }\n    else {\n        toPath.buildPath(toPathProxy, toPath.shape);\n    }\n    var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a[0], toBezierCurves = _a[1];\n    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n    becomeIndividualMorphingPath(toPath, morphingData, 0);\n    var oldDone = animationOpts && animationOpts.done;\n    var oldAborted = animationOpts && animationOpts.aborted;\n    var oldDuring = animationOpts && animationOpts.during;\n    toPath.animateTo({\n        __morphT: 1\n    }, defaults({\n        during: function (p) {\n            toPath.dirtyShape();\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            restoreIndividualMorphingPath(toPath);\n            toPath.createPathProxy();\n            toPath.dirtyShape();\n            oldDone && oldDone();\n        },\n        aborted: function () {\n            oldAborted && oldAborted();\n        }\n    }, animationOpts));\n    return toPath;\n}\nfunction morphingPathBuildPath(path) {\n    var morphingData = this.__morphingData;\n    var t = this.__morphT;\n    var onet = 1 - t;\n    var newCp = [];\n    for (var i = 0; i < morphingData.length; i++) {\n        var item = morphingData[i];\n        var from = item.from;\n        var to = item.to;\n        var angle = item.rotation * t;\n        var fromCp = item.fromCp;\n        var toCp = item.toCp;\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        lerp(newCp, fromCp, toCp, t);\n        for (var m = 0; m < from.length; m += 2) {\n            var x0 = from[m];\n            var y0 = from[m + 1];\n            var x1 = to[m];\n            var y1 = to[m + 1];\n            var x = x0 * onet + x1 * t;\n            var y = y0 * onet + y1 * t;\n            tmpArr[m] = (x * ca - y * sa) + newCp[0];\n            tmpArr[m + 1] = (x * sa + y * ca) + newCp[1];\n        }\n        for (var m = 0; m < from.length;) {\n            if (m === 0) {\n                path.moveTo(tmpArr[m++], tmpArr[m++]);\n            }\n            path.bezierCurveTo(tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++]);\n        }\n    }\n}\n;\nfunction becomeIndividualMorphingPath(path, morphingData, morphT) {\n    if (isIndividualMorphingPath(path)) {\n        updateIndividualMorphingPath(path, morphingData, morphT);\n        return;\n    }\n    var morphingPath = path;\n    morphingPath.__oldBuildPath = morphingPath.buildPath;\n    morphingPath.buildPath = morphingPathBuildPath;\n    updateIndividualMorphingPath(morphingPath, morphingData, morphT);\n}\nfunction updateIndividualMorphingPath(morphingPath, morphingData, morphT) {\n    morphingPath.__morphingData = morphingData;\n    morphingPath.__morphT = morphT;\n}\nfunction restoreIndividualMorphingPath(path) {\n    if (isIndividualMorphingPath(path)) {\n        path.buildPath = path.__oldBuildPath;\n        path.__oldBuildPath = path.__morphingData = null;\n    }\n}\nfunction isIndividualMorphingPath(path) {\n    return path.__oldBuildPath != null;\n}\nexport function isCombiningPath(path) {\n    return !!path.__combiningSubList;\n}\nexport function isInAnyMorphing(path) {\n    return isIndividualMorphingPath(path) || isCombiningPath(path);\n}\nexport function combine(fromPathList, toPath, animationOpts, copyPropsIfDivided) {\n    var fromIndividuals = [];\n    var separateCount = 0;\n    for (var i = 0; i < fromPathList.length; i++) {\n        var fromPath = fromPathList[i];\n        if (isCombiningPath(fromPath)) {\n            var fromCombiningSubList = fromPath.__combiningSubList;\n            for (var j = 0; j < fromCombiningSubList.length; j++) {\n                fromIndividuals.push(fromCombiningSubList[j]);\n            }\n            separateCount += fromCombiningSubList.length;\n        }\n        else {\n            fromIndividuals.push(fromPath);\n            separateCount++;\n        }\n    }\n    if (!separateCount) {\n        return;\n    }\n    var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n    var toPathSplittedList = divideShape(toPath, separateCount, dividingMethod);\n    assert(toPathSplittedList.length === separateCount);\n    var oldDone = animationOpts && animationOpts.done;\n    var oldAborted = animationOpts && animationOpts.aborted;\n    var oldDuring = animationOpts && animationOpts.during;\n    var doneCount = 0;\n    var abortedCalled = false;\n    var morphAnimationOpts = defaults({\n        during: function (p) {\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            doneCount++;\n            if (doneCount === toPathSplittedList.length) {\n                restoreCombiningPath(toPath);\n                oldDone && oldDone();\n            }\n        },\n        aborted: function () {\n            if (!abortedCalled) {\n                abortedCalled = true;\n                oldAborted && oldAborted();\n            }\n        }\n    }, animationOpts);\n    for (var i = 0; i < separateCount; i++) {\n        var from = fromIndividuals[i];\n        var to = toPathSplittedList[i];\n        copyPropsIfDivided && copyPropsIfDivided(toPath, to, true);\n        morphPath(from, to, morphAnimationOpts);\n    }\n    becomeCombiningPath(toPath, toPathSplittedList);\n    return {\n        fromIndividuals: fromIndividuals,\n        toIndividuals: toPathSplittedList,\n        count: separateCount\n    };\n}\nfunction becomeCombiningPath(path, combiningSubList) {\n    if (isCombiningPath(path)) {\n        updateCombiningPathSubList(path, combiningSubList);\n        return;\n    }\n    var combiningPath = path;\n    updateCombiningPathSubList(combiningPath, combiningSubList);\n    combiningPath.__oldAddSelfToZr = path.addSelfToZr;\n    combiningPath.__oldRemoveSelfFromZr = path.removeSelfFromZr;\n    combiningPath.addSelfToZr = combiningAddSelfToZr;\n    combiningPath.removeSelfFromZr = combiningRemoveSelfFromZr;\n    combiningPath.__oldBuildPath = combiningPath.buildPath;\n    combiningPath.buildPath = noop;\n    combiningPath.childrenRef = combiningChildrenRef;\n}\nfunction restoreCombiningPath(path) {\n    if (!isCombiningPath(path)) {\n        return;\n    }\n    var combiningPath = path;\n    updateCombiningPathSubList(combiningPath, null);\n    combiningPath.addSelfToZr = combiningPath.__oldAddSelfToZr;\n    combiningPath.removeSelfFromZr = combiningPath.__oldRemoveSelfFromZr;\n    combiningPath.buildPath = combiningPath.__oldBuildPath;\n    combiningPath.childrenRef =\n        combiningPath.__combiningSubList =\n            combiningPath.__oldAddSelfToZr =\n                combiningPath.__oldRemoveSelfFromZr =\n                    combiningPath.__oldBuildPath = null;\n}\nfunction updateCombiningPathSubList(combiningPath, combiningSubList) {\n    if (combiningPath.__combiningSubList !== combiningSubList) {\n        combiningPathSubListAddRemoveWithZr(combiningPath, 'removeSelfFromZr');\n        combiningPath.__combiningSubList = combiningSubList;\n        if (combiningSubList) {\n            for (var i = 0; i < combiningSubList.length; i++) {\n                combiningSubList[i].parent = combiningPath;\n            }\n        }\n        combiningPathSubListAddRemoveWithZr(combiningPath, 'addSelfToZr');\n    }\n}\nfunction combiningAddSelfToZr(zr) {\n    this.__oldAddSelfToZr(zr);\n    combiningPathSubListAddRemoveWithZr(this, 'addSelfToZr');\n}\nfunction combiningPathSubListAddRemoveWithZr(path, method) {\n    var combiningSubList = path.__combiningSubList;\n    var zr = path.__zr;\n    if (combiningSubList && zr) {\n        for (var i = 0; i < combiningSubList.length; i++) {\n            var child = combiningSubList[i];\n            child[method](zr);\n        }\n    }\n}\nfunction combiningRemoveSelfFromZr(zr) {\n    this.__oldRemoveSelfFromZr(zr);\n    var combiningSubList = this.__combiningSubList;\n    for (var i = 0; i < combiningSubList.length; i++) {\n        var child = combiningSubList[i];\n        child.removeSelfFromZr(zr);\n    }\n}\nfunction combiningChildrenRef() {\n    return this.__combiningSubList;\n}\nexport function separate(fromPath, toPathList, animationOpts, copyPropsIfDivided) {\n    var toPathListLen = toPathList.length;\n    var fromPathList;\n    var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n    var copyProps = false;\n    if (isCombiningPath(fromPath)) {\n        var fromCombiningSubList = fromPath.__combiningSubList;\n        if (fromCombiningSubList.length === toPathListLen) {\n            fromPathList = fromCombiningSubList;\n        }\n        else {\n            fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n            copyProps = true;\n        }\n    }\n    else {\n        fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n        copyProps = true;\n    }\n    assert(fromPathList.length === toPathListLen);\n    for (var i = 0; i < toPathListLen; i++) {\n        if (copyProps && copyPropsIfDivided) {\n            copyPropsIfDivided(fromPath, fromPathList[i], false);\n        }\n        morphPath(fromPathList[i], toPathList[i], animationOpts);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toPathList,\n        count: toPathListLen\n    };\n}\nfunction divideShape(path, separateCount, dividingMethod) {\n    return dividingMethod === 'duplicate'\n        ? duplicateShape(path, separateCount)\n        : splitShape(path, separateCount);\n}\nfunction splitShape(path, separateCount) {\n    var resultPaths = [];\n    if (separateCount <= 0) {\n        return resultPaths;\n    }\n    if (separateCount === 1) {\n        return duplicateShape(path, separateCount);\n    }\n    if (path instanceof Rect) {\n        var toPathShape = path.shape;\n        var splitPropIdx = toPathShape.height > toPathShape.width ? 1 : 0;\n        var propWH = PROP_WH[splitPropIdx];\n        var propXY = PROP_XY[splitPropIdx];\n        var subWH = toPathShape[propWH] / separateCount;\n        var xyCurr = toPathShape[propXY];\n        for (var i = 0; i < separateCount; i++, xyCurr += subWH) {\n            var subShape = {\n                x: toPathShape.x,\n                y: toPathShape.y,\n                width: toPathShape.width,\n                height: toPathShape.height\n            };\n            subShape[propXY] = xyCurr;\n            subShape[propWH] = i < separateCount - 1\n                ? subWH\n                : toPathShape[propXY] + toPathShape[propWH] - xyCurr;\n            var splitted = new Rect({ shape: subShape });\n            resultPaths.push(splitted);\n        }\n    }\n    else if (path instanceof Sector) {\n        var toPathShape = path.shape;\n        var clockwise = toPathShape.clockwise;\n        var startAngle = toPathShape.startAngle;\n        var endAngle = toPathShape.endAngle;\n        var endAngleNormalized = normalizeRadian(startAngle, toPathShape.endAngle, clockwise);\n        var step = (endAngleNormalized - startAngle) / separateCount;\n        var angleCurr = startAngle;\n        for (var i = 0; i < separateCount; i++, angleCurr += step) {\n            var splitted = new Sector({\n                shape: {\n                    cx: toPathShape.cx,\n                    cy: toPathShape.cy,\n                    r: toPathShape.r,\n                    r0: toPathShape.r0,\n                    clockwise: clockwise,\n                    startAngle: angleCurr,\n                    endAngle: i === separateCount - 1 ? endAngle : angleCurr + step\n                }\n            });\n            resultPaths.push(splitted);\n        }\n    }\n    else {\n        return duplicateShape(path, separateCount);\n    }\n    return resultPaths;\n}\nfunction duplicateShape(path, separateCount) {\n    var resultPaths = [];\n    if (separateCount <= 0) {\n        return resultPaths;\n    }\n    var ctor = path.constructor;\n    for (var i = 0; i < separateCount; i++) {\n        var sub = new ctor({\n            shape: clone(path.shape)\n        });\n        resultPaths.push(sub);\n    }\n    return resultPaths;\n}\nfunction normalizeRadian(start, end, clockwise) {\n    return end + PI2 * (Math[clockwise ? 'ceil' : 'floor']((start - end) / PI2));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}