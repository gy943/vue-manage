{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport PointerPath from './PointerPath';\nimport * as graphic from '../../util/graphic';\nimport { setStatesStylesFromModel, enableHoverEmphasis } from '../../util/states';\nimport { createTextStyle, setLabelValueAnimation, animateLabelValue } from '../../label/labelStyle';\nimport ChartView from '../../view/Chart';\nimport { parsePercent, round, linearMap } from '../../util/number';\nimport Sausage from '../../util/shape/sausage';\nimport { createSymbol } from '../../util/symbol';\nimport ZRImage from 'zrender/lib/graphic/Image';\nimport { extend } from 'zrender/lib/core/util';\n\nfunction parsePosition(seriesModel, api) {\n  var center = seriesModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var size = Math.min(width, height);\n  var cx = parsePercent(center[0], api.getWidth());\n  var cy = parsePercent(center[1], api.getHeight());\n  var r = parsePercent(seriesModel.get('radius'), size / 2);\n  return {\n    cx: cx,\n    cy: cy,\n    r: r\n  };\n}\n\nfunction formatLabel(value, labelFormatter) {\n  var label = value == null ? '' : value + '';\n\n  if (labelFormatter) {\n    if (typeof labelFormatter === 'string') {\n      label = labelFormatter.replace('{value}', label);\n    } else if (typeof labelFormatter === 'function') {\n      label = labelFormatter(value);\n    }\n  }\n\n  return label;\n}\n\nvar PI2 = Math.PI * 2;\n\nvar GaugeView =\n/** @class */\nfunction (_super) {\n  __extends(GaugeView, _super);\n\n  function GaugeView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = GaugeView.type;\n    return _this;\n  }\n\n  GaugeView.prototype.render = function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n    var colorList = seriesModel.get(['axisLine', 'lineStyle', 'color']);\n    var posInfo = parsePosition(seriesModel, api);\n\n    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n\n    this._data = seriesModel.getData();\n  };\n\n  GaugeView.prototype.dispose = function () {};\n\n  GaugeView.prototype._renderMain = function (seriesModel, ecModel, api, colorList, posInfo) {\n    var group = this.group;\n    var clockwise = seriesModel.get('clockwise');\n    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n    var axisLineModel = seriesModel.getModel('axisLine');\n    var roundCap = axisLineModel.get('roundCap');\n    var MainPath = roundCap ? Sausage : graphic.Sector;\n    var showAxis = axisLineModel.get('show');\n    var lineStyleModel = axisLineModel.getModel('lineStyle');\n    var axisLineWidth = lineStyleModel.get('width');\n    var angleRangeSpan = !((endAngle - startAngle) % PI2) && endAngle !== startAngle ? PI2 : (endAngle - startAngle) % PI2;\n    var prevEndAngle = startAngle;\n\n    for (var i = 0; showAxis && i < colorList.length; i++) {\n      // Clamp\n      var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n      endAngle = startAngle + angleRangeSpan * percent;\n      var sector = new MainPath({\n        shape: {\n          startAngle: prevEndAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: posInfo.r - axisLineWidth,\n          r: posInfo.r\n        },\n        silent: true\n      });\n      sector.setStyle({\n        fill: colorList[i][1]\n      });\n      sector.setStyle(lineStyleModel.getLineStyle( // Because we use sector to simulate arc\n      // so the properties for stroking are useless\n      ['color', 'width']));\n      group.add(sector);\n      prevEndAngle = endAngle;\n    }\n\n    var getColor = function (percent) {\n      // Less than 0\n      if (percent <= 0) {\n        return colorList[0][1];\n      }\n\n      var i;\n\n      for (i = 0; i < colorList.length; i++) {\n        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n          return colorList[i][1];\n        }\n      } // More than 1\n\n\n      return colorList[i - 1][1];\n    };\n\n    if (!clockwise) {\n      var tmp = startAngle;\n      startAngle = endAngle;\n      endAngle = tmp;\n    }\n\n    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n\n    this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);\n\n    this._renderAnchor(seriesModel, posInfo);\n\n    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n  };\n\n  GaugeView.prototype._renderTicks = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var cx = posInfo.cx;\n    var cy = posInfo.cy;\n    var r = posInfo.r;\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var splitLineModel = seriesModel.getModel('splitLine');\n    var tickModel = seriesModel.getModel('axisTick');\n    var labelModel = seriesModel.getModel('axisLabel');\n    var splitNumber = seriesModel.get('splitNumber');\n    var subSplitNumber = tickModel.get('splitNumber');\n    var splitLineLen = parsePercent(splitLineModel.get('length'), r);\n    var tickLen = parsePercent(tickModel.get('length'), r);\n    var angle = startAngle;\n    var step = (endAngle - startAngle) / splitNumber;\n    var subStep = step / subSplitNumber;\n    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n    var splitLineDistance = splitLineModel.get('distance');\n    var unitX;\n    var unitY;\n\n    for (var i = 0; i <= splitNumber; i++) {\n      unitX = Math.cos(angle);\n      unitY = Math.sin(angle); // Split line\n\n      if (splitLineModel.get('show')) {\n        var distance = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;\n        var splitLine = new graphic.Line({\n          shape: {\n            x1: unitX * (r - distance) + cx,\n            y1: unitY * (r - distance) + cy,\n            x2: unitX * (r - splitLineLen - distance) + cx,\n            y2: unitY * (r - splitLineLen - distance) + cy\n          },\n          style: splitLineStyle,\n          silent: true\n        });\n\n        if (splitLineStyle.stroke === 'auto') {\n          splitLine.setStyle({\n            stroke: getColor(i / splitNumber)\n          });\n        }\n\n        group.add(splitLine);\n      } // Label\n\n\n      if (labelModel.get('show')) {\n        var distance = labelModel.get('distance') + splitLineDistance;\n        var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n        var autoColor = getColor(i / splitNumber);\n        group.add(new graphic.Text({\n          style: createTextStyle(labelModel, {\n            text: label,\n            x: unitX * (r - splitLineLen - distance) + cx,\n            y: unitY * (r - splitLineLen - distance) + cy,\n            verticalAlign: unitY < -0.8 ? 'top' : unitY > 0.8 ? 'bottom' : 'middle',\n            align: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n          }, {\n            inheritColor: autoColor\n          }),\n          silent: true\n        }));\n      } // Axis tick\n\n\n      if (tickModel.get('show') && i !== splitNumber) {\n        var distance = tickModel.get('distance');\n        distance = distance ? distance + axisLineWidth : axisLineWidth;\n\n        for (var j = 0; j <= subSplitNumber; j++) {\n          unitX = Math.cos(angle);\n          unitY = Math.sin(angle);\n          var tickLine = new graphic.Line({\n            shape: {\n              x1: unitX * (r - distance) + cx,\n              y1: unitY * (r - distance) + cy,\n              x2: unitX * (r - tickLen - distance) + cx,\n              y2: unitY * (r - tickLen - distance) + cy\n            },\n            silent: true,\n            style: tickLineStyle\n          });\n\n          if (tickLineStyle.stroke === 'auto') {\n            tickLine.setStyle({\n              stroke: getColor((i + j / subSplitNumber) / splitNumber)\n            });\n          }\n\n          group.add(tickLine);\n          angle += subStep;\n        }\n\n        angle -= subStep;\n      } else {\n        angle += step;\n      }\n    }\n  };\n\n  GaugeView.prototype._renderPointer = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var oldData = this._data;\n    var oldProgressData = this._progressEls;\n    var progressList = [];\n    var showPointer = seriesModel.get(['pointer', 'show']);\n    var progressModel = seriesModel.getModel('progress');\n    var showProgress = progressModel.get('show');\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var valueExtent = [minVal, maxVal];\n    var angleExtent = [startAngle, endAngle];\n\n    function createPointer(idx, angle) {\n      var itemModel = data.getItemModel(idx);\n      var pointerModel = itemModel.getModel('pointer');\n      var pointerWidth = parsePercent(pointerModel.get('width'), posInfo.r);\n      var pointerLength = parsePercent(pointerModel.get('length'), posInfo.r);\n      var pointerStr = seriesModel.get(['pointer', 'icon']);\n      var pointerOffset = pointerModel.get('offsetCenter');\n      var pointerOffsetX = parsePercent(pointerOffset[0], posInfo.r);\n      var pointerOffsetY = parsePercent(pointerOffset[1], posInfo.r);\n      var pointerKeepAspect = pointerModel.get('keepAspect');\n      var pointer; // not exist icon type will be set 'rect'\n\n      if (pointerStr) {\n        pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);\n      } else {\n        pointer = new PointerPath({\n          shape: {\n            angle: -Math.PI / 2,\n            width: pointerWidth,\n            r: pointerLength,\n            x: pointerOffsetX,\n            y: pointerOffsetY\n          }\n        });\n      }\n\n      pointer.rotation = -(angle + Math.PI / 2);\n      pointer.x = posInfo.cx;\n      pointer.y = posInfo.cy;\n      return pointer;\n    }\n\n    function createProgress(idx, endAngle) {\n      var roundCap = progressModel.get('roundCap');\n      var ProgressPath = roundCap ? Sausage : graphic.Sector;\n      var isOverlap = progressModel.get('overlap');\n      var progressWidth = isOverlap ? progressModel.get('width') : axisLineWidth / data.count();\n      var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;\n      var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;\n      var progress = new ProgressPath({\n        shape: {\n          startAngle: startAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: r0,\n          r: r\n        }\n      });\n      isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);\n      return progress;\n    }\n\n    if (showProgress || showPointer) {\n      data.diff(oldData).add(function (idx) {\n        if (showPointer) {\n          var pointer = createPointer(idx, startAngle);\n          graphic.initProps(pointer, {\n            rotation: -(linearMap(data.get(valueDim, idx), valueExtent, angleExtent, true) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(idx, pointer);\n        }\n\n        if (showProgress) {\n          var progress = createProgress(idx, startAngle);\n          var isClip = progressModel.get('clip');\n          graphic.initProps(progress, {\n            shape: {\n              endAngle: linearMap(data.get(valueDim, idx), valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress);\n          progressList[idx] = progress;\n        }\n      }).update(function (newIdx, oldIdx) {\n        if (showPointer) {\n          var previousPointer = oldData.getItemGraphicEl(oldIdx);\n          var previousRotate = previousPointer ? previousPointer.rotation : startAngle;\n          var pointer = createPointer(newIdx, previousRotate);\n          pointer.rotation = previousRotate;\n          graphic.updateProps(pointer, {\n            rotation: -(linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, true) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(newIdx, pointer);\n        }\n\n        if (showProgress) {\n          var previousProgress = oldProgressData[oldIdx];\n          var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;\n          var progress = createProgress(newIdx, previousEndAngle);\n          var isClip = progressModel.get('clip');\n          graphic.updateProps(progress, {\n            shape: {\n              endAngle: linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress);\n          progressList[newIdx] = progress;\n        }\n      }).execute();\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var emphasisModel = itemModel.getModel('emphasis');\n\n        if (showPointer) {\n          var pointer = data.getItemGraphicEl(idx);\n          var symbolStyle = data.getItemVisual(idx, 'style');\n          var visualColor = symbolStyle.fill;\n\n          if (pointer instanceof ZRImage) {\n            var pathStyle = pointer.style;\n            pointer.useStyle(extend({\n              image: pathStyle.image,\n              x: pathStyle.x,\n              y: pathStyle.y,\n              width: pathStyle.width,\n              height: pathStyle.height\n            }, symbolStyle));\n          } else {\n            pointer.useStyle(symbolStyle);\n            pointer.type !== 'pointer' && pointer.setColor(visualColor);\n          }\n\n          pointer.setStyle(itemModel.getModel(['pointer', 'itemStyle']).getItemStyle());\n\n          if (pointer.style.fill === 'auto') {\n            pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n          }\n\n          pointer.z2EmphasisLift = 0;\n          setStatesStylesFromModel(pointer, itemModel);\n          enableHoverEmphasis(pointer, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n        }\n\n        if (showProgress) {\n          var progress = progressList[idx];\n          progress.useStyle(data.getItemVisual(idx, 'style'));\n          progress.setStyle(itemModel.getModel(['progress', 'itemStyle']).getItemStyle());\n          progress.z2EmphasisLift = 0;\n          setStatesStylesFromModel(progress, itemModel);\n          enableHoverEmphasis(progress, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n        }\n      });\n      this._progressEls = progressList;\n    }\n  };\n\n  GaugeView.prototype._renderAnchor = function (seriesModel, posInfo) {\n    var anchorModel = seriesModel.getModel('anchor');\n    var showAnchor = anchorModel.get('show');\n\n    if (showAnchor) {\n      var anchorSize = anchorModel.get('size');\n      var anchorType = anchorModel.get('icon');\n      var offsetCenter = anchorModel.get('offsetCenter');\n      var anchorKeepAspect = anchorModel.get('keepAspect');\n      var anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);\n      anchor.z2 = anchorModel.get('showAbove') ? 1 : 0;\n      anchor.setStyle(anchorModel.getModel('itemStyle').getItemStyle());\n      this.group.add(anchor);\n    }\n  };\n\n  GaugeView.prototype._renderTitleAndDetail = function (seriesModel, ecModel, api, getColor, posInfo) {\n    var _this = this;\n\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var contentGroup = new graphic.Group();\n    var newTitleEls = [];\n    var newDetailEls = [];\n    var hasAnimation = seriesModel.isAnimationEnabled();\n    data.diff(this._data).add(function (idx) {\n      newTitleEls[idx] = new graphic.Text({\n        silent: true\n      });\n      newDetailEls[idx] = new graphic.Text({\n        silent: true\n      });\n    }).update(function (idx, oldIdx) {\n      newTitleEls[idx] = _this._titleEls[oldIdx];\n      newDetailEls[idx] = _this._detailEls[oldIdx];\n    }).execute();\n    data.each(function (idx) {\n      var itemModel = data.getItemModel(idx);\n      var value = data.get(valueDim, idx);\n      var itemGroup = new graphic.Group();\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      var itemTitleModel = itemModel.getModel('title');\n\n      if (itemTitleModel.get('show')) {\n        var titleOffsetCenter = itemTitleModel.get('offsetCenter');\n        var titleX = posInfo.cx + parsePercent(titleOffsetCenter[0], posInfo.r);\n        var titleY = posInfo.cy + parsePercent(titleOffsetCenter[1], posInfo.r);\n        var labelEl = newTitleEls[idx];\n        labelEl.attr({\n          style: createTextStyle(itemTitleModel, {\n            x: titleX,\n            y: titleY,\n            text: data.getName(idx),\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: autoColor\n          })\n        });\n        itemGroup.add(labelEl);\n      }\n\n      var itemDetailModel = itemModel.getModel('detail');\n\n      if (itemDetailModel.get('show')) {\n        var detailOffsetCenter = itemDetailModel.get('offsetCenter');\n        var detailX = posInfo.cx + parsePercent(detailOffsetCenter[0], posInfo.r);\n        var detailY = posInfo.cy + parsePercent(detailOffsetCenter[1], posInfo.r);\n        var width = parsePercent(itemDetailModel.get('width'), posInfo.r);\n        var height = parsePercent(itemDetailModel.get('height'), posInfo.r);\n        var detailColor = seriesModel.get(['progress', 'show']) ? data.getItemVisual(idx, 'style').fill : autoColor;\n        var labelEl = newDetailEls[idx];\n        var formatter_1 = itemDetailModel.get('formatter');\n        labelEl.attr({\n          style: createTextStyle(itemDetailModel, {\n            x: detailX,\n            y: detailY,\n            text: formatLabel(value, formatter_1),\n            width: isNaN(width) ? null : width,\n            height: isNaN(height) ? null : height,\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: detailColor\n          })\n        });\n        setLabelValueAnimation(labelEl, {\n          normal: itemDetailModel\n        }, value, function (value) {\n          return formatLabel(value, formatter_1);\n        });\n        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {\n          getFormattedLabel: function (labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {\n            return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);\n          }\n        });\n        itemGroup.add(labelEl);\n      }\n\n      contentGroup.add(itemGroup);\n    });\n    this.group.add(contentGroup);\n    this._titleEls = newTitleEls;\n    this._detailEls = newDetailEls;\n  };\n\n  GaugeView.type = 'gauge';\n  return GaugeView;\n}(ChartView);\n\nexport default GaugeView;","map":{"version":3,"names":["__extends","PointerPath","graphic","setStatesStylesFromModel","enableHoverEmphasis","createTextStyle","setLabelValueAnimation","animateLabelValue","ChartView","parsePercent","round","linearMap","Sausage","createSymbol","ZRImage","extend","parsePosition","seriesModel","api","center","get","width","getWidth","height","getHeight","size","Math","min","cx","cy","r","formatLabel","value","labelFormatter","label","replace","PI2","PI","GaugeView","_super","_this","apply","arguments","type","prototype","render","ecModel","group","removeAll","colorList","posInfo","_renderMain","_data","getData","dispose","clockwise","startAngle","endAngle","axisLineModel","getModel","roundCap","MainPath","Sector","showAxis","lineStyleModel","axisLineWidth","angleRangeSpan","prevEndAngle","i","length","percent","max","sector","shape","r0","silent","setStyle","fill","getLineStyle","add","getColor","tmp","_renderTicks","_renderTitleAndDetail","_renderAnchor","_renderPointer","minVal","maxVal","splitLineModel","tickModel","labelModel","splitNumber","subSplitNumber","splitLineLen","tickLen","angle","step","subStep","splitLineStyle","tickLineStyle","splitLineDistance","unitX","unitY","cos","sin","distance","splitLine","Line","x1","y1","x2","y2","style","stroke","autoColor","Text","text","x","y","verticalAlign","align","inheritColor","j","tickLine","oldData","oldProgressData","_progressEls","progressList","showPointer","progressModel","showProgress","data","valueDim","mapDimension","valueExtent","angleExtent","createPointer","idx","itemModel","getItemModel","pointerModel","pointerWidth","pointerLength","pointerStr","pointerOffset","pointerOffsetX","pointerOffsetY","pointerKeepAspect","pointer","rotation","createProgress","ProgressPath","isOverlap","progressWidth","count","progress","z2","diff","initProps","setItemGraphicEl","isClip","update","newIdx","oldIdx","previousPointer","getItemGraphicEl","previousRotate","updateProps","previousProgress","previousEndAngle","execute","each","emphasisModel","symbolStyle","getItemVisual","visualColor","pathStyle","useStyle","image","setColor","getItemStyle","z2EmphasisLift","anchorModel","showAnchor","anchorSize","anchorType","offsetCenter","anchorKeepAspect","anchor","contentGroup","Group","newTitleEls","newDetailEls","hasAnimation","isAnimationEnabled","_titleEls","_detailEls","itemGroup","itemTitleModel","titleOffsetCenter","titleX","titleY","labelEl","attr","getName","itemDetailModel","detailOffsetCenter","detailX","detailY","detailColor","formatter_1","isNaN","normal","getFormattedLabel","labelDataIndex","status","dataType","labelDimIndex","fmt","extendParams","interpolatedValue"],"sources":["E:/school/qianduan/web/vue-manage/node_modules/echarts/lib/chart/gauge/GaugeView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport PointerPath from './PointerPath';\nimport * as graphic from '../../util/graphic';\nimport { setStatesStylesFromModel, enableHoverEmphasis } from '../../util/states';\nimport { createTextStyle, setLabelValueAnimation, animateLabelValue } from '../../label/labelStyle';\nimport ChartView from '../../view/Chart';\nimport { parsePercent, round, linearMap } from '../../util/number';\nimport Sausage from '../../util/shape/sausage';\nimport { createSymbol } from '../../util/symbol';\nimport ZRImage from 'zrender/lib/graphic/Image';\nimport { extend } from 'zrender/lib/core/util';\n\nfunction parsePosition(seriesModel, api) {\n  var center = seriesModel.get('center');\n  var width = api.getWidth();\n  var height = api.getHeight();\n  var size = Math.min(width, height);\n  var cx = parsePercent(center[0], api.getWidth());\n  var cy = parsePercent(center[1], api.getHeight());\n  var r = parsePercent(seriesModel.get('radius'), size / 2);\n  return {\n    cx: cx,\n    cy: cy,\n    r: r\n  };\n}\n\nfunction formatLabel(value, labelFormatter) {\n  var label = value == null ? '' : value + '';\n\n  if (labelFormatter) {\n    if (typeof labelFormatter === 'string') {\n      label = labelFormatter.replace('{value}', label);\n    } else if (typeof labelFormatter === 'function') {\n      label = labelFormatter(value);\n    }\n  }\n\n  return label;\n}\n\nvar PI2 = Math.PI * 2;\n\nvar GaugeView =\n/** @class */\nfunction (_super) {\n  __extends(GaugeView, _super);\n\n  function GaugeView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = GaugeView.type;\n    return _this;\n  }\n\n  GaugeView.prototype.render = function (seriesModel, ecModel, api) {\n    this.group.removeAll();\n    var colorList = seriesModel.get(['axisLine', 'lineStyle', 'color']);\n    var posInfo = parsePosition(seriesModel, api);\n\n    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);\n\n    this._data = seriesModel.getData();\n  };\n\n  GaugeView.prototype.dispose = function () {};\n\n  GaugeView.prototype._renderMain = function (seriesModel, ecModel, api, colorList, posInfo) {\n    var group = this.group;\n    var clockwise = seriesModel.get('clockwise');\n    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;\n    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;\n    var axisLineModel = seriesModel.getModel('axisLine');\n    var roundCap = axisLineModel.get('roundCap');\n    var MainPath = roundCap ? Sausage : graphic.Sector;\n    var showAxis = axisLineModel.get('show');\n    var lineStyleModel = axisLineModel.getModel('lineStyle');\n    var axisLineWidth = lineStyleModel.get('width');\n    var angleRangeSpan = !((endAngle - startAngle) % PI2) && endAngle !== startAngle ? PI2 : (endAngle - startAngle) % PI2;\n    var prevEndAngle = startAngle;\n\n    for (var i = 0; showAxis && i < colorList.length; i++) {\n      // Clamp\n      var percent = Math.min(Math.max(colorList[i][0], 0), 1);\n      endAngle = startAngle + angleRangeSpan * percent;\n      var sector = new MainPath({\n        shape: {\n          startAngle: prevEndAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: posInfo.r - axisLineWidth,\n          r: posInfo.r\n        },\n        silent: true\n      });\n      sector.setStyle({\n        fill: colorList[i][1]\n      });\n      sector.setStyle(lineStyleModel.getLineStyle( // Because we use sector to simulate arc\n      // so the properties for stroking are useless\n      ['color', 'width']));\n      group.add(sector);\n      prevEndAngle = endAngle;\n    }\n\n    var getColor = function (percent) {\n      // Less than 0\n      if (percent <= 0) {\n        return colorList[0][1];\n      }\n\n      var i;\n\n      for (i = 0; i < colorList.length; i++) {\n        if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {\n          return colorList[i][1];\n        }\n      } // More than 1\n\n\n      return colorList[i - 1][1];\n    };\n\n    if (!clockwise) {\n      var tmp = startAngle;\n      startAngle = endAngle;\n      endAngle = tmp;\n    }\n\n    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n\n    this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo);\n\n    this._renderAnchor(seriesModel, posInfo);\n\n    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth);\n  };\n\n  GaugeView.prototype._renderTicks = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var cx = posInfo.cx;\n    var cy = posInfo.cy;\n    var r = posInfo.r;\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var splitLineModel = seriesModel.getModel('splitLine');\n    var tickModel = seriesModel.getModel('axisTick');\n    var labelModel = seriesModel.getModel('axisLabel');\n    var splitNumber = seriesModel.get('splitNumber');\n    var subSplitNumber = tickModel.get('splitNumber');\n    var splitLineLen = parsePercent(splitLineModel.get('length'), r);\n    var tickLen = parsePercent(tickModel.get('length'), r);\n    var angle = startAngle;\n    var step = (endAngle - startAngle) / splitNumber;\n    var subStep = step / subSplitNumber;\n    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();\n    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();\n    var splitLineDistance = splitLineModel.get('distance');\n    var unitX;\n    var unitY;\n\n    for (var i = 0; i <= splitNumber; i++) {\n      unitX = Math.cos(angle);\n      unitY = Math.sin(angle); // Split line\n\n      if (splitLineModel.get('show')) {\n        var distance = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth;\n        var splitLine = new graphic.Line({\n          shape: {\n            x1: unitX * (r - distance) + cx,\n            y1: unitY * (r - distance) + cy,\n            x2: unitX * (r - splitLineLen - distance) + cx,\n            y2: unitY * (r - splitLineLen - distance) + cy\n          },\n          style: splitLineStyle,\n          silent: true\n        });\n\n        if (splitLineStyle.stroke === 'auto') {\n          splitLine.setStyle({\n            stroke: getColor(i / splitNumber)\n          });\n        }\n\n        group.add(splitLine);\n      } // Label\n\n\n      if (labelModel.get('show')) {\n        var distance = labelModel.get('distance') + splitLineDistance;\n        var label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));\n        var autoColor = getColor(i / splitNumber);\n        group.add(new graphic.Text({\n          style: createTextStyle(labelModel, {\n            text: label,\n            x: unitX * (r - splitLineLen - distance) + cx,\n            y: unitY * (r - splitLineLen - distance) + cy,\n            verticalAlign: unitY < -0.8 ? 'top' : unitY > 0.8 ? 'bottom' : 'middle',\n            align: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'\n          }, {\n            inheritColor: autoColor\n          }),\n          silent: true\n        }));\n      } // Axis tick\n\n\n      if (tickModel.get('show') && i !== splitNumber) {\n        var distance = tickModel.get('distance');\n        distance = distance ? distance + axisLineWidth : axisLineWidth;\n\n        for (var j = 0; j <= subSplitNumber; j++) {\n          unitX = Math.cos(angle);\n          unitY = Math.sin(angle);\n          var tickLine = new graphic.Line({\n            shape: {\n              x1: unitX * (r - distance) + cx,\n              y1: unitY * (r - distance) + cy,\n              x2: unitX * (r - tickLen - distance) + cx,\n              y2: unitY * (r - tickLen - distance) + cy\n            },\n            silent: true,\n            style: tickLineStyle\n          });\n\n          if (tickLineStyle.stroke === 'auto') {\n            tickLine.setStyle({\n              stroke: getColor((i + j / subSplitNumber) / splitNumber)\n            });\n          }\n\n          group.add(tickLine);\n          angle += subStep;\n        }\n\n        angle -= subStep;\n      } else {\n        angle += step;\n      }\n    }\n  };\n\n  GaugeView.prototype._renderPointer = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {\n    var group = this.group;\n    var oldData = this._data;\n    var oldProgressData = this._progressEls;\n    var progressList = [];\n    var showPointer = seriesModel.get(['pointer', 'show']);\n    var progressModel = seriesModel.getModel('progress');\n    var showProgress = progressModel.get('show');\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var valueExtent = [minVal, maxVal];\n    var angleExtent = [startAngle, endAngle];\n\n    function createPointer(idx, angle) {\n      var itemModel = data.getItemModel(idx);\n      var pointerModel = itemModel.getModel('pointer');\n      var pointerWidth = parsePercent(pointerModel.get('width'), posInfo.r);\n      var pointerLength = parsePercent(pointerModel.get('length'), posInfo.r);\n      var pointerStr = seriesModel.get(['pointer', 'icon']);\n      var pointerOffset = pointerModel.get('offsetCenter');\n      var pointerOffsetX = parsePercent(pointerOffset[0], posInfo.r);\n      var pointerOffsetY = parsePercent(pointerOffset[1], posInfo.r);\n      var pointerKeepAspect = pointerModel.get('keepAspect');\n      var pointer; // not exist icon type will be set 'rect'\n\n      if (pointerStr) {\n        pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect);\n      } else {\n        pointer = new PointerPath({\n          shape: {\n            angle: -Math.PI / 2,\n            width: pointerWidth,\n            r: pointerLength,\n            x: pointerOffsetX,\n            y: pointerOffsetY\n          }\n        });\n      }\n\n      pointer.rotation = -(angle + Math.PI / 2);\n      pointer.x = posInfo.cx;\n      pointer.y = posInfo.cy;\n      return pointer;\n    }\n\n    function createProgress(idx, endAngle) {\n      var roundCap = progressModel.get('roundCap');\n      var ProgressPath = roundCap ? Sausage : graphic.Sector;\n      var isOverlap = progressModel.get('overlap');\n      var progressWidth = isOverlap ? progressModel.get('width') : axisLineWidth / data.count();\n      var r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth;\n      var r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth;\n      var progress = new ProgressPath({\n        shape: {\n          startAngle: startAngle,\n          endAngle: endAngle,\n          cx: posInfo.cx,\n          cy: posInfo.cy,\n          clockwise: clockwise,\n          r0: r0,\n          r: r\n        }\n      });\n      isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal);\n      return progress;\n    }\n\n    if (showProgress || showPointer) {\n      data.diff(oldData).add(function (idx) {\n        if (showPointer) {\n          var pointer = createPointer(idx, startAngle);\n          graphic.initProps(pointer, {\n            rotation: -(linearMap(data.get(valueDim, idx), valueExtent, angleExtent, true) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(idx, pointer);\n        }\n\n        if (showProgress) {\n          var progress = createProgress(idx, startAngle);\n          var isClip = progressModel.get('clip');\n          graphic.initProps(progress, {\n            shape: {\n              endAngle: linearMap(data.get(valueDim, idx), valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress);\n          progressList[idx] = progress;\n        }\n      }).update(function (newIdx, oldIdx) {\n        if (showPointer) {\n          var previousPointer = oldData.getItemGraphicEl(oldIdx);\n          var previousRotate = previousPointer ? previousPointer.rotation : startAngle;\n          var pointer = createPointer(newIdx, previousRotate);\n          pointer.rotation = previousRotate;\n          graphic.updateProps(pointer, {\n            rotation: -(linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, true) + Math.PI / 2)\n          }, seriesModel);\n          group.add(pointer);\n          data.setItemGraphicEl(newIdx, pointer);\n        }\n\n        if (showProgress) {\n          var previousProgress = oldProgressData[oldIdx];\n          var previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle;\n          var progress = createProgress(newIdx, previousEndAngle);\n          var isClip = progressModel.get('clip');\n          graphic.updateProps(progress, {\n            shape: {\n              endAngle: linearMap(data.get(valueDim, newIdx), valueExtent, angleExtent, isClip)\n            }\n          }, seriesModel);\n          group.add(progress);\n          progressList[newIdx] = progress;\n        }\n      }).execute();\n      data.each(function (idx) {\n        var itemModel = data.getItemModel(idx);\n        var emphasisModel = itemModel.getModel('emphasis');\n\n        if (showPointer) {\n          var pointer = data.getItemGraphicEl(idx);\n          var symbolStyle = data.getItemVisual(idx, 'style');\n          var visualColor = symbolStyle.fill;\n\n          if (pointer instanceof ZRImage) {\n            var pathStyle = pointer.style;\n            pointer.useStyle(extend({\n              image: pathStyle.image,\n              x: pathStyle.x,\n              y: pathStyle.y,\n              width: pathStyle.width,\n              height: pathStyle.height\n            }, symbolStyle));\n          } else {\n            pointer.useStyle(symbolStyle);\n            pointer.type !== 'pointer' && pointer.setColor(visualColor);\n          }\n\n          pointer.setStyle(itemModel.getModel(['pointer', 'itemStyle']).getItemStyle());\n\n          if (pointer.style.fill === 'auto') {\n            pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)));\n          }\n\n          pointer.z2EmphasisLift = 0;\n          setStatesStylesFromModel(pointer, itemModel);\n          enableHoverEmphasis(pointer, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n        }\n\n        if (showProgress) {\n          var progress = progressList[idx];\n          progress.useStyle(data.getItemVisual(idx, 'style'));\n          progress.setStyle(itemModel.getModel(['progress', 'itemStyle']).getItemStyle());\n          progress.z2EmphasisLift = 0;\n          setStatesStylesFromModel(progress, itemModel);\n          enableHoverEmphasis(progress, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n        }\n      });\n      this._progressEls = progressList;\n    }\n  };\n\n  GaugeView.prototype._renderAnchor = function (seriesModel, posInfo) {\n    var anchorModel = seriesModel.getModel('anchor');\n    var showAnchor = anchorModel.get('show');\n\n    if (showAnchor) {\n      var anchorSize = anchorModel.get('size');\n      var anchorType = anchorModel.get('icon');\n      var offsetCenter = anchorModel.get('offsetCenter');\n      var anchorKeepAspect = anchorModel.get('keepAspect');\n      var anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect);\n      anchor.z2 = anchorModel.get('showAbove') ? 1 : 0;\n      anchor.setStyle(anchorModel.getModel('itemStyle').getItemStyle());\n      this.group.add(anchor);\n    }\n  };\n\n  GaugeView.prototype._renderTitleAndDetail = function (seriesModel, ecModel, api, getColor, posInfo) {\n    var _this = this;\n\n    var data = seriesModel.getData();\n    var valueDim = data.mapDimension('value');\n    var minVal = +seriesModel.get('min');\n    var maxVal = +seriesModel.get('max');\n    var contentGroup = new graphic.Group();\n    var newTitleEls = [];\n    var newDetailEls = [];\n    var hasAnimation = seriesModel.isAnimationEnabled();\n    data.diff(this._data).add(function (idx) {\n      newTitleEls[idx] = new graphic.Text({\n        silent: true\n      });\n      newDetailEls[idx] = new graphic.Text({\n        silent: true\n      });\n    }).update(function (idx, oldIdx) {\n      newTitleEls[idx] = _this._titleEls[oldIdx];\n      newDetailEls[idx] = _this._detailEls[oldIdx];\n    }).execute();\n    data.each(function (idx) {\n      var itemModel = data.getItemModel(idx);\n      var value = data.get(valueDim, idx);\n      var itemGroup = new graphic.Group();\n      var autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true));\n      var itemTitleModel = itemModel.getModel('title');\n\n      if (itemTitleModel.get('show')) {\n        var titleOffsetCenter = itemTitleModel.get('offsetCenter');\n        var titleX = posInfo.cx + parsePercent(titleOffsetCenter[0], posInfo.r);\n        var titleY = posInfo.cy + parsePercent(titleOffsetCenter[1], posInfo.r);\n        var labelEl = newTitleEls[idx];\n        labelEl.attr({\n          style: createTextStyle(itemTitleModel, {\n            x: titleX,\n            y: titleY,\n            text: data.getName(idx),\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: autoColor\n          })\n        });\n        itemGroup.add(labelEl);\n      }\n\n      var itemDetailModel = itemModel.getModel('detail');\n\n      if (itemDetailModel.get('show')) {\n        var detailOffsetCenter = itemDetailModel.get('offsetCenter');\n        var detailX = posInfo.cx + parsePercent(detailOffsetCenter[0], posInfo.r);\n        var detailY = posInfo.cy + parsePercent(detailOffsetCenter[1], posInfo.r);\n        var width = parsePercent(itemDetailModel.get('width'), posInfo.r);\n        var height = parsePercent(itemDetailModel.get('height'), posInfo.r);\n        var detailColor = seriesModel.get(['progress', 'show']) ? data.getItemVisual(idx, 'style').fill : autoColor;\n        var labelEl = newDetailEls[idx];\n        var formatter_1 = itemDetailModel.get('formatter');\n        labelEl.attr({\n          style: createTextStyle(itemDetailModel, {\n            x: detailX,\n            y: detailY,\n            text: formatLabel(value, formatter_1),\n            width: isNaN(width) ? null : width,\n            height: isNaN(height) ? null : height,\n            align: 'center',\n            verticalAlign: 'middle'\n          }, {\n            inheritColor: detailColor\n          })\n        });\n        setLabelValueAnimation(labelEl, {\n          normal: itemDetailModel\n        }, value, function (value) {\n          return formatLabel(value, formatter_1);\n        });\n        hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {\n          getFormattedLabel: function (labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {\n            return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1);\n          }\n        });\n        itemGroup.add(labelEl);\n      }\n\n      contentGroup.add(itemGroup);\n    });\n    this.group.add(contentGroup);\n    this._titleEls = newTitleEls;\n    this._detailEls = newDetailEls;\n  };\n\n  GaugeView.type = 'gauge';\n  return GaugeView;\n}(ChartView);\n\nexport default GaugeView;"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,SAAT,QAA0B,OAA1B;AACA,OAAOC,WAAP,MAAwB,eAAxB;AACA,OAAO,KAAKC,OAAZ,MAAyB,oBAAzB;AACA,SAASC,wBAAT,EAAmCC,mBAAnC,QAA8D,mBAA9D;AACA,SAASC,eAAT,EAA0BC,sBAA1B,EAAkDC,iBAAlD,QAA2E,wBAA3E;AACA,OAAOC,SAAP,MAAsB,kBAAtB;AACA,SAASC,YAAT,EAAuBC,KAAvB,EAA8BC,SAA9B,QAA+C,mBAA/C;AACA,OAAOC,OAAP,MAAoB,0BAApB;AACA,SAASC,YAAT,QAA6B,mBAA7B;AACA,OAAOC,OAAP,MAAoB,2BAApB;AACA,SAASC,MAAT,QAAuB,uBAAvB;;AAEA,SAASC,aAAT,CAAuBC,WAAvB,EAAoCC,GAApC,EAAyC;EACvC,IAAIC,MAAM,GAAGF,WAAW,CAACG,GAAZ,CAAgB,QAAhB,CAAb;EACA,IAAIC,KAAK,GAAGH,GAAG,CAACI,QAAJ,EAAZ;EACA,IAAIC,MAAM,GAAGL,GAAG,CAACM,SAAJ,EAAb;EACA,IAAIC,IAAI,GAAGC,IAAI,CAACC,GAAL,CAASN,KAAT,EAAgBE,MAAhB,CAAX;EACA,IAAIK,EAAE,GAAGnB,YAAY,CAACU,MAAM,CAAC,CAAD,CAAP,EAAYD,GAAG,CAACI,QAAJ,EAAZ,CAArB;EACA,IAAIO,EAAE,GAAGpB,YAAY,CAACU,MAAM,CAAC,CAAD,CAAP,EAAYD,GAAG,CAACM,SAAJ,EAAZ,CAArB;EACA,IAAIM,CAAC,GAAGrB,YAAY,CAACQ,WAAW,CAACG,GAAZ,CAAgB,QAAhB,CAAD,EAA4BK,IAAI,GAAG,CAAnC,CAApB;EACA,OAAO;IACLG,EAAE,EAAEA,EADC;IAELC,EAAE,EAAEA,EAFC;IAGLC,CAAC,EAAEA;EAHE,CAAP;AAKD;;AAED,SAASC,WAAT,CAAqBC,KAArB,EAA4BC,cAA5B,EAA4C;EAC1C,IAAIC,KAAK,GAAGF,KAAK,IAAI,IAAT,GAAgB,EAAhB,GAAqBA,KAAK,GAAG,EAAzC;;EAEA,IAAIC,cAAJ,EAAoB;IAClB,IAAI,OAAOA,cAAP,KAA0B,QAA9B,EAAwC;MACtCC,KAAK,GAAGD,cAAc,CAACE,OAAf,CAAuB,SAAvB,EAAkCD,KAAlC,CAAR;IACD,CAFD,MAEO,IAAI,OAAOD,cAAP,KAA0B,UAA9B,EAA0C;MAC/CC,KAAK,GAAGD,cAAc,CAACD,KAAD,CAAtB;IACD;EACF;;EAED,OAAOE,KAAP;AACD;;AAED,IAAIE,GAAG,GAAGV,IAAI,CAACW,EAAL,GAAU,CAApB;;AAEA,IAAIC,SAAS;AACb;AACA,UAAUC,MAAV,EAAkB;EAChBvC,SAAS,CAACsC,SAAD,EAAYC,MAAZ,CAAT;;EAEA,SAASD,SAAT,GAAqB;IACnB,IAAIE,KAAK,GAAGD,MAAM,KAAK,IAAX,IAAmBA,MAAM,CAACE,KAAP,CAAa,IAAb,EAAmBC,SAAnB,CAAnB,IAAoD,IAAhE;;IAEAF,KAAK,CAACG,IAAN,GAAaL,SAAS,CAACK,IAAvB;IACA,OAAOH,KAAP;EACD;;EAEDF,SAAS,CAACM,SAAV,CAAoBC,MAApB,GAA6B,UAAU5B,WAAV,EAAuB6B,OAAvB,EAAgC5B,GAAhC,EAAqC;IAChE,KAAK6B,KAAL,CAAWC,SAAX;IACA,IAAIC,SAAS,GAAGhC,WAAW,CAACG,GAAZ,CAAgB,CAAC,UAAD,EAAa,WAAb,EAA0B,OAA1B,CAAhB,CAAhB;IACA,IAAI8B,OAAO,GAAGlC,aAAa,CAACC,WAAD,EAAcC,GAAd,CAA3B;;IAEA,KAAKiC,WAAL,CAAiBlC,WAAjB,EAA8B6B,OAA9B,EAAuC5B,GAAvC,EAA4C+B,SAA5C,EAAuDC,OAAvD;;IAEA,KAAKE,KAAL,GAAanC,WAAW,CAACoC,OAAZ,EAAb;EACD,CARD;;EAUAf,SAAS,CAACM,SAAV,CAAoBU,OAApB,GAA8B,YAAY,CAAE,CAA5C;;EAEAhB,SAAS,CAACM,SAAV,CAAoBO,WAApB,GAAkC,UAAUlC,WAAV,EAAuB6B,OAAvB,EAAgC5B,GAAhC,EAAqC+B,SAArC,EAAgDC,OAAhD,EAAyD;IACzF,IAAIH,KAAK,GAAG,KAAKA,KAAjB;IACA,IAAIQ,SAAS,GAAGtC,WAAW,CAACG,GAAZ,CAAgB,WAAhB,CAAhB;IACA,IAAIoC,UAAU,GAAG,CAACvC,WAAW,CAACG,GAAZ,CAAgB,YAAhB,CAAD,GAAiC,GAAjC,GAAuCM,IAAI,CAACW,EAA7D;IACA,IAAIoB,QAAQ,GAAG,CAACxC,WAAW,CAACG,GAAZ,CAAgB,UAAhB,CAAD,GAA+B,GAA/B,GAAqCM,IAAI,CAACW,EAAzD;IACA,IAAIqB,aAAa,GAAGzC,WAAW,CAAC0C,QAAZ,CAAqB,UAArB,CAApB;IACA,IAAIC,QAAQ,GAAGF,aAAa,CAACtC,GAAd,CAAkB,UAAlB,CAAf;IACA,IAAIyC,QAAQ,GAAGD,QAAQ,GAAGhD,OAAH,GAAaV,OAAO,CAAC4D,MAA5C;IACA,IAAIC,QAAQ,GAAGL,aAAa,CAACtC,GAAd,CAAkB,MAAlB,CAAf;IACA,IAAI4C,cAAc,GAAGN,aAAa,CAACC,QAAd,CAAuB,WAAvB,CAArB;IACA,IAAIM,aAAa,GAAGD,cAAc,CAAC5C,GAAf,CAAmB,OAAnB,CAApB;IACA,IAAI8C,cAAc,GAAG,EAAE,CAACT,QAAQ,GAAGD,UAAZ,IAA0BpB,GAA5B,KAAoCqB,QAAQ,KAAKD,UAAjD,GAA8DpB,GAA9D,GAAoE,CAACqB,QAAQ,GAAGD,UAAZ,IAA0BpB,GAAnH;IACA,IAAI+B,YAAY,GAAGX,UAAnB;;IAEA,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBL,QAAQ,IAAIK,CAAC,GAAGnB,SAAS,CAACoB,MAA1C,EAAkDD,CAAC,EAAnD,EAAuD;MACrD;MACA,IAAIE,OAAO,GAAG5C,IAAI,CAACC,GAAL,CAASD,IAAI,CAAC6C,GAAL,CAAStB,SAAS,CAACmB,CAAD,CAAT,CAAa,CAAb,CAAT,EAA0B,CAA1B,CAAT,EAAuC,CAAvC,CAAd;MACAX,QAAQ,GAAGD,UAAU,GAAGU,cAAc,GAAGI,OAAzC;MACA,IAAIE,MAAM,GAAG,IAAIX,QAAJ,CAAa;QACxBY,KAAK,EAAE;UACLjB,UAAU,EAAEW,YADP;UAELV,QAAQ,EAAEA,QAFL;UAGL7B,EAAE,EAAEsB,OAAO,CAACtB,EAHP;UAILC,EAAE,EAAEqB,OAAO,CAACrB,EAJP;UAKL0B,SAAS,EAAEA,SALN;UAMLmB,EAAE,EAAExB,OAAO,CAACpB,CAAR,GAAYmC,aANX;UAOLnC,CAAC,EAAEoB,OAAO,CAACpB;QAPN,CADiB;QAUxB6C,MAAM,EAAE;MAVgB,CAAb,CAAb;MAYAH,MAAM,CAACI,QAAP,CAAgB;QACdC,IAAI,EAAE5B,SAAS,CAACmB,CAAD,CAAT,CAAa,CAAb;MADQ,CAAhB;MAGAI,MAAM,CAACI,QAAP,CAAgBZ,cAAc,CAACc,YAAf,EAA6B;MAC7C;MACA,CAAC,OAAD,EAAU,OAAV,CAFgB,CAAhB;MAGA/B,KAAK,CAACgC,GAAN,CAAUP,MAAV;MACAL,YAAY,GAAGV,QAAf;IACD;;IAED,IAAIuB,QAAQ,GAAG,UAAUV,OAAV,EAAmB;MAChC;MACA,IAAIA,OAAO,IAAI,CAAf,EAAkB;QAChB,OAAOrB,SAAS,CAAC,CAAD,CAAT,CAAa,CAAb,CAAP;MACD;;MAED,IAAImB,CAAJ;;MAEA,KAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGnB,SAAS,CAACoB,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;QACrC,IAAInB,SAAS,CAACmB,CAAD,CAAT,CAAa,CAAb,KAAmBE,OAAnB,IAA8B,CAACF,CAAC,KAAK,CAAN,GAAU,CAAV,GAAcnB,SAAS,CAACmB,CAAC,GAAG,CAAL,CAAT,CAAiB,CAAjB,CAAf,IAAsCE,OAAxE,EAAiF;UAC/E,OAAOrB,SAAS,CAACmB,CAAD,CAAT,CAAa,CAAb,CAAP;QACD;MACF,CAZ+B,CAY9B;;;MAGF,OAAOnB,SAAS,CAACmB,CAAC,GAAG,CAAL,CAAT,CAAiB,CAAjB,CAAP;IACD,CAhBD;;IAkBA,IAAI,CAACb,SAAL,EAAgB;MACd,IAAI0B,GAAG,GAAGzB,UAAV;MACAA,UAAU,GAAGC,QAAb;MACAA,QAAQ,GAAGwB,GAAX;IACD;;IAED,KAAKC,YAAL,CAAkBjE,WAAlB,EAA+B6B,OAA/B,EAAwC5B,GAAxC,EAA6C8D,QAA7C,EAAuD9B,OAAvD,EAAgEM,UAAhE,EAA4EC,QAA5E,EAAsFF,SAAtF,EAAiGU,aAAjG;;IAEA,KAAKkB,qBAAL,CAA2BlE,WAA3B,EAAwC6B,OAAxC,EAAiD5B,GAAjD,EAAsD8D,QAAtD,EAAgE9B,OAAhE;;IAEA,KAAKkC,aAAL,CAAmBnE,WAAnB,EAAgCiC,OAAhC;;IAEA,KAAKmC,cAAL,CAAoBpE,WAApB,EAAiC6B,OAAjC,EAA0C5B,GAA1C,EAA+C8D,QAA/C,EAAyD9B,OAAzD,EAAkEM,UAAlE,EAA8EC,QAA9E,EAAwFF,SAAxF,EAAmGU,aAAnG;EACD,CAvED;;EAyEA3B,SAAS,CAACM,SAAV,CAAoBsC,YAApB,GAAmC,UAAUjE,WAAV,EAAuB6B,OAAvB,EAAgC5B,GAAhC,EAAqC8D,QAArC,EAA+C9B,OAA/C,EAAwDM,UAAxD,EAAoEC,QAApE,EAA8EF,SAA9E,EAAyFU,aAAzF,EAAwG;IACzI,IAAIlB,KAAK,GAAG,KAAKA,KAAjB;IACA,IAAInB,EAAE,GAAGsB,OAAO,CAACtB,EAAjB;IACA,IAAIC,EAAE,GAAGqB,OAAO,CAACrB,EAAjB;IACA,IAAIC,CAAC,GAAGoB,OAAO,CAACpB,CAAhB;IACA,IAAIwD,MAAM,GAAG,CAACrE,WAAW,CAACG,GAAZ,CAAgB,KAAhB,CAAd;IACA,IAAImE,MAAM,GAAG,CAACtE,WAAW,CAACG,GAAZ,CAAgB,KAAhB,CAAd;IACA,IAAIoE,cAAc,GAAGvE,WAAW,CAAC0C,QAAZ,CAAqB,WAArB,CAArB;IACA,IAAI8B,SAAS,GAAGxE,WAAW,CAAC0C,QAAZ,CAAqB,UAArB,CAAhB;IACA,IAAI+B,UAAU,GAAGzE,WAAW,CAAC0C,QAAZ,CAAqB,WAArB,CAAjB;IACA,IAAIgC,WAAW,GAAG1E,WAAW,CAACG,GAAZ,CAAgB,aAAhB,CAAlB;IACA,IAAIwE,cAAc,GAAGH,SAAS,CAACrE,GAAV,CAAc,aAAd,CAArB;IACA,IAAIyE,YAAY,GAAGpF,YAAY,CAAC+E,cAAc,CAACpE,GAAf,CAAmB,QAAnB,CAAD,EAA+BU,CAA/B,CAA/B;IACA,IAAIgE,OAAO,GAAGrF,YAAY,CAACgF,SAAS,CAACrE,GAAV,CAAc,QAAd,CAAD,EAA0BU,CAA1B,CAA1B;IACA,IAAIiE,KAAK,GAAGvC,UAAZ;IACA,IAAIwC,IAAI,GAAG,CAACvC,QAAQ,GAAGD,UAAZ,IAA0BmC,WAArC;IACA,IAAIM,OAAO,GAAGD,IAAI,GAAGJ,cAArB;IACA,IAAIM,cAAc,GAAGV,cAAc,CAAC7B,QAAf,CAAwB,WAAxB,EAAqCmB,YAArC,EAArB;IACA,IAAIqB,aAAa,GAAGV,SAAS,CAAC9B,QAAV,CAAmB,WAAnB,EAAgCmB,YAAhC,EAApB;IACA,IAAIsB,iBAAiB,GAAGZ,cAAc,CAACpE,GAAf,CAAmB,UAAnB,CAAxB;IACA,IAAIiF,KAAJ;IACA,IAAIC,KAAJ;;IAEA,KAAK,IAAIlC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIuB,WAArB,EAAkCvB,CAAC,EAAnC,EAAuC;MACrCiC,KAAK,GAAG3E,IAAI,CAAC6E,GAAL,CAASR,KAAT,CAAR;MACAO,KAAK,GAAG5E,IAAI,CAAC8E,GAAL,CAAST,KAAT,CAAR,CAFqC,CAEZ;;MAEzB,IAAIP,cAAc,CAACpE,GAAf,CAAmB,MAAnB,CAAJ,EAAgC;QAC9B,IAAIqF,QAAQ,GAAGL,iBAAiB,GAAGA,iBAAiB,GAAGnC,aAAvB,GAAuCA,aAAvE;QACA,IAAIyC,SAAS,GAAG,IAAIxG,OAAO,CAACyG,IAAZ,CAAiB;UAC/BlC,KAAK,EAAE;YACLmC,EAAE,EAAEP,KAAK,IAAIvE,CAAC,GAAG2E,QAAR,CAAL,GAAyB7E,EADxB;YAELiF,EAAE,EAAEP,KAAK,IAAIxE,CAAC,GAAG2E,QAAR,CAAL,GAAyB5E,EAFxB;YAGLiF,EAAE,EAAET,KAAK,IAAIvE,CAAC,GAAG+D,YAAJ,GAAmBY,QAAvB,CAAL,GAAwC7E,EAHvC;YAILmF,EAAE,EAAET,KAAK,IAAIxE,CAAC,GAAG+D,YAAJ,GAAmBY,QAAvB,CAAL,GAAwC5E;UAJvC,CADwB;UAO/BmF,KAAK,EAAEd,cAPwB;UAQ/BvB,MAAM,EAAE;QARuB,CAAjB,CAAhB;;QAWA,IAAIuB,cAAc,CAACe,MAAf,KAA0B,MAA9B,EAAsC;UACpCP,SAAS,CAAC9B,QAAV,CAAmB;YACjBqC,MAAM,EAAEjC,QAAQ,CAACZ,CAAC,GAAGuB,WAAL;UADC,CAAnB;QAGD;;QAED5C,KAAK,CAACgC,GAAN,CAAU2B,SAAV;MACD,CAxBoC,CAwBnC;;;MAGF,IAAIhB,UAAU,CAACtE,GAAX,CAAe,MAAf,CAAJ,EAA4B;QAC1B,IAAIqF,QAAQ,GAAGf,UAAU,CAACtE,GAAX,CAAe,UAAf,IAA6BgF,iBAA5C;QACA,IAAIlE,KAAK,GAAGH,WAAW,CAACrB,KAAK,CAAC0D,CAAC,GAAGuB,WAAJ,IAAmBJ,MAAM,GAAGD,MAA5B,IAAsCA,MAAvC,CAAN,EAAsDI,UAAU,CAACtE,GAAX,CAAe,WAAf,CAAtD,CAAvB;QACA,IAAI8F,SAAS,GAAGlC,QAAQ,CAACZ,CAAC,GAAGuB,WAAL,CAAxB;QACA5C,KAAK,CAACgC,GAAN,CAAU,IAAI7E,OAAO,CAACiH,IAAZ,CAAiB;UACzBH,KAAK,EAAE3G,eAAe,CAACqF,UAAD,EAAa;YACjC0B,IAAI,EAAElF,KAD2B;YAEjCmF,CAAC,EAAEhB,KAAK,IAAIvE,CAAC,GAAG+D,YAAJ,GAAmBY,QAAvB,CAAL,GAAwC7E,EAFV;YAGjC0F,CAAC,EAAEhB,KAAK,IAAIxE,CAAC,GAAG+D,YAAJ,GAAmBY,QAAvB,CAAL,GAAwC5E,EAHV;YAIjC0F,aAAa,EAAEjB,KAAK,GAAG,CAAC,GAAT,GAAe,KAAf,GAAuBA,KAAK,GAAG,GAAR,GAAc,QAAd,GAAyB,QAJ9B;YAKjCkB,KAAK,EAAEnB,KAAK,GAAG,CAAC,GAAT,GAAe,MAAf,GAAwBA,KAAK,GAAG,GAAR,GAAc,OAAd,GAAwB;UALtB,CAAb,EAMnB;YACDoB,YAAY,EAAEP;UADb,CANmB,CADG;UAUzBvC,MAAM,EAAE;QAViB,CAAjB,CAAV;MAYD,CA3CoC,CA2CnC;;;MAGF,IAAIc,SAAS,CAACrE,GAAV,CAAc,MAAd,KAAyBgD,CAAC,KAAKuB,WAAnC,EAAgD;QAC9C,IAAIc,QAAQ,GAAGhB,SAAS,CAACrE,GAAV,CAAc,UAAd,CAAf;QACAqF,QAAQ,GAAGA,QAAQ,GAAGA,QAAQ,GAAGxC,aAAd,GAA8BA,aAAjD;;QAEA,KAAK,IAAIyD,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI9B,cAArB,EAAqC8B,CAAC,EAAtC,EAA0C;UACxCrB,KAAK,GAAG3E,IAAI,CAAC6E,GAAL,CAASR,KAAT,CAAR;UACAO,KAAK,GAAG5E,IAAI,CAAC8E,GAAL,CAAST,KAAT,CAAR;UACA,IAAI4B,QAAQ,GAAG,IAAIzH,OAAO,CAACyG,IAAZ,CAAiB;YAC9BlC,KAAK,EAAE;cACLmC,EAAE,EAAEP,KAAK,IAAIvE,CAAC,GAAG2E,QAAR,CAAL,GAAyB7E,EADxB;cAELiF,EAAE,EAAEP,KAAK,IAAIxE,CAAC,GAAG2E,QAAR,CAAL,GAAyB5E,EAFxB;cAGLiF,EAAE,EAAET,KAAK,IAAIvE,CAAC,GAAGgE,OAAJ,GAAcW,QAAlB,CAAL,GAAmC7E,EAHlC;cAILmF,EAAE,EAAET,KAAK,IAAIxE,CAAC,GAAGgE,OAAJ,GAAcW,QAAlB,CAAL,GAAmC5E;YAJlC,CADuB;YAO9B8C,MAAM,EAAE,IAPsB;YAQ9BqC,KAAK,EAAEb;UARuB,CAAjB,CAAf;;UAWA,IAAIA,aAAa,CAACc,MAAd,KAAyB,MAA7B,EAAqC;YACnCU,QAAQ,CAAC/C,QAAT,CAAkB;cAChBqC,MAAM,EAAEjC,QAAQ,CAAC,CAACZ,CAAC,GAAGsD,CAAC,GAAG9B,cAAT,IAA2BD,WAA5B;YADA,CAAlB;UAGD;;UAED5C,KAAK,CAACgC,GAAN,CAAU4C,QAAV;UACA5B,KAAK,IAAIE,OAAT;QACD;;QAEDF,KAAK,IAAIE,OAAT;MACD,CA7BD,MA6BO;QACLF,KAAK,IAAIC,IAAT;MACD;IACF;EACF,CAtGD;;EAwGA1D,SAAS,CAACM,SAAV,CAAoByC,cAApB,GAAqC,UAAUpE,WAAV,EAAuB6B,OAAvB,EAAgC5B,GAAhC,EAAqC8D,QAArC,EAA+C9B,OAA/C,EAAwDM,UAAxD,EAAoEC,QAApE,EAA8EF,SAA9E,EAAyFU,aAAzF,EAAwG;IAC3I,IAAIlB,KAAK,GAAG,KAAKA,KAAjB;IACA,IAAI6E,OAAO,GAAG,KAAKxE,KAAnB;IACA,IAAIyE,eAAe,GAAG,KAAKC,YAA3B;IACA,IAAIC,YAAY,GAAG,EAAnB;IACA,IAAIC,WAAW,GAAG/G,WAAW,CAACG,GAAZ,CAAgB,CAAC,SAAD,EAAY,MAAZ,CAAhB,CAAlB;IACA,IAAI6G,aAAa,GAAGhH,WAAW,CAAC0C,QAAZ,CAAqB,UAArB,CAApB;IACA,IAAIuE,YAAY,GAAGD,aAAa,CAAC7G,GAAd,CAAkB,MAAlB,CAAnB;IACA,IAAI+G,IAAI,GAAGlH,WAAW,CAACoC,OAAZ,EAAX;IACA,IAAI+E,QAAQ,GAAGD,IAAI,CAACE,YAAL,CAAkB,OAAlB,CAAf;IACA,IAAI/C,MAAM,GAAG,CAACrE,WAAW,CAACG,GAAZ,CAAgB,KAAhB,CAAd;IACA,IAAImE,MAAM,GAAG,CAACtE,WAAW,CAACG,GAAZ,CAAgB,KAAhB,CAAd;IACA,IAAIkH,WAAW,GAAG,CAAChD,MAAD,EAASC,MAAT,CAAlB;IACA,IAAIgD,WAAW,GAAG,CAAC/E,UAAD,EAAaC,QAAb,CAAlB;;IAEA,SAAS+E,aAAT,CAAuBC,GAAvB,EAA4B1C,KAA5B,EAAmC;MACjC,IAAI2C,SAAS,GAAGP,IAAI,CAACQ,YAAL,CAAkBF,GAAlB,CAAhB;MACA,IAAIG,YAAY,GAAGF,SAAS,CAAC/E,QAAV,CAAmB,SAAnB,CAAnB;MACA,IAAIkF,YAAY,GAAGpI,YAAY,CAACmI,YAAY,CAACxH,GAAb,CAAiB,OAAjB,CAAD,EAA4B8B,OAAO,CAACpB,CAApC,CAA/B;MACA,IAAIgH,aAAa,GAAGrI,YAAY,CAACmI,YAAY,CAACxH,GAAb,CAAiB,QAAjB,CAAD,EAA6B8B,OAAO,CAACpB,CAArC,CAAhC;MACA,IAAIiH,UAAU,GAAG9H,WAAW,CAACG,GAAZ,CAAgB,CAAC,SAAD,EAAY,MAAZ,CAAhB,CAAjB;MACA,IAAI4H,aAAa,GAAGJ,YAAY,CAACxH,GAAb,CAAiB,cAAjB,CAApB;MACA,IAAI6H,cAAc,GAAGxI,YAAY,CAACuI,aAAa,CAAC,CAAD,CAAd,EAAmB9F,OAAO,CAACpB,CAA3B,CAAjC;MACA,IAAIoH,cAAc,GAAGzI,YAAY,CAACuI,aAAa,CAAC,CAAD,CAAd,EAAmB9F,OAAO,CAACpB,CAA3B,CAAjC;MACA,IAAIqH,iBAAiB,GAAGP,YAAY,CAACxH,GAAb,CAAiB,YAAjB,CAAxB;MACA,IAAIgI,OAAJ,CAViC,CAUpB;;MAEb,IAAIL,UAAJ,EAAgB;QACdK,OAAO,GAAGvI,YAAY,CAACkI,UAAD,EAAaE,cAAc,GAAGJ,YAAY,GAAG,CAA7C,EAAgDK,cAAc,GAAGJ,aAAjE,EAAgFD,YAAhF,EAA8FC,aAA9F,EAA6G,IAA7G,EAAmHK,iBAAnH,CAAtB;MACD,CAFD,MAEO;QACLC,OAAO,GAAG,IAAInJ,WAAJ,CAAgB;UACxBwE,KAAK,EAAE;YACLsB,KAAK,EAAE,CAACrE,IAAI,CAACW,EAAN,GAAW,CADb;YAELhB,KAAK,EAAEwH,YAFF;YAGL/G,CAAC,EAAEgH,aAHE;YAILzB,CAAC,EAAE4B,cAJE;YAKL3B,CAAC,EAAE4B;UALE;QADiB,CAAhB,CAAV;MASD;;MAEDE,OAAO,CAACC,QAAR,GAAmB,EAAEtD,KAAK,GAAGrE,IAAI,CAACW,EAAL,GAAU,CAApB,CAAnB;MACA+G,OAAO,CAAC/B,CAAR,GAAYnE,OAAO,CAACtB,EAApB;MACAwH,OAAO,CAAC9B,CAAR,GAAYpE,OAAO,CAACrB,EAApB;MACA,OAAOuH,OAAP;IACD;;IAED,SAASE,cAAT,CAAwBb,GAAxB,EAA6BhF,QAA7B,EAAuC;MACrC,IAAIG,QAAQ,GAAGqE,aAAa,CAAC7G,GAAd,CAAkB,UAAlB,CAAf;MACA,IAAImI,YAAY,GAAG3F,QAAQ,GAAGhD,OAAH,GAAaV,OAAO,CAAC4D,MAAhD;MACA,IAAI0F,SAAS,GAAGvB,aAAa,CAAC7G,GAAd,CAAkB,SAAlB,CAAhB;MACA,IAAIqI,aAAa,GAAGD,SAAS,GAAGvB,aAAa,CAAC7G,GAAd,CAAkB,OAAlB,CAAH,GAAgC6C,aAAa,GAAGkE,IAAI,CAACuB,KAAL,EAA7E;MACA,IAAIhF,EAAE,GAAG8E,SAAS,GAAGtG,OAAO,CAACpB,CAAR,GAAY2H,aAAf,GAA+BvG,OAAO,CAACpB,CAAR,GAAY,CAAC2G,GAAG,GAAG,CAAP,IAAYgB,aAAzE;MACA,IAAI3H,CAAC,GAAG0H,SAAS,GAAGtG,OAAO,CAACpB,CAAX,GAAeoB,OAAO,CAACpB,CAAR,GAAY2G,GAAG,GAAGgB,aAAlD;MACA,IAAIE,QAAQ,GAAG,IAAIJ,YAAJ,CAAiB;QAC9B9E,KAAK,EAAE;UACLjB,UAAU,EAAEA,UADP;UAELC,QAAQ,EAAEA,QAFL;UAGL7B,EAAE,EAAEsB,OAAO,CAACtB,EAHP;UAILC,EAAE,EAAEqB,OAAO,CAACrB,EAJP;UAKL0B,SAAS,EAAEA,SALN;UAMLmB,EAAE,EAAEA,EANC;UAOL5C,CAAC,EAAEA;QAPE;MADuB,CAAjB,CAAf;MAWA0H,SAAS,KAAKG,QAAQ,CAACC,EAAT,GAAcrE,MAAM,GAAG4C,IAAI,CAAC/G,GAAL,CAASgH,QAAT,EAAmBK,GAAnB,IAA0BlD,MAAtD,CAAT;MACA,OAAOoE,QAAP;IACD;;IAED,IAAIzB,YAAY,IAAIF,WAApB,EAAiC;MAC/BG,IAAI,CAAC0B,IAAL,CAAUjC,OAAV,EAAmB7C,GAAnB,CAAuB,UAAU0D,GAAV,EAAe;QACpC,IAAIT,WAAJ,EAAiB;UACf,IAAIoB,OAAO,GAAGZ,aAAa,CAACC,GAAD,EAAMjF,UAAN,CAA3B;UACAtD,OAAO,CAAC4J,SAAR,CAAkBV,OAAlB,EAA2B;YACzBC,QAAQ,EAAE,EAAE1I,SAAS,CAACwH,IAAI,CAAC/G,GAAL,CAASgH,QAAT,EAAmBK,GAAnB,CAAD,EAA0BH,WAA1B,EAAuCC,WAAvC,EAAoD,IAApD,CAAT,GAAqE7G,IAAI,CAACW,EAAL,GAAU,CAAjF;UADe,CAA3B,EAEGpB,WAFH;UAGA8B,KAAK,CAACgC,GAAN,CAAUqE,OAAV;UACAjB,IAAI,CAAC4B,gBAAL,CAAsBtB,GAAtB,EAA2BW,OAA3B;QACD;;QAED,IAAIlB,YAAJ,EAAkB;UAChB,IAAIyB,QAAQ,GAAGL,cAAc,CAACb,GAAD,EAAMjF,UAAN,CAA7B;UACA,IAAIwG,MAAM,GAAG/B,aAAa,CAAC7G,GAAd,CAAkB,MAAlB,CAAb;UACAlB,OAAO,CAAC4J,SAAR,CAAkBH,QAAlB,EAA4B;YAC1BlF,KAAK,EAAE;cACLhB,QAAQ,EAAE9C,SAAS,CAACwH,IAAI,CAAC/G,GAAL,CAASgH,QAAT,EAAmBK,GAAnB,CAAD,EAA0BH,WAA1B,EAAuCC,WAAvC,EAAoDyB,MAApD;YADd;UADmB,CAA5B,EAIG/I,WAJH;UAKA8B,KAAK,CAACgC,GAAN,CAAU4E,QAAV;UACA5B,YAAY,CAACU,GAAD,CAAZ,GAAoBkB,QAApB;QACD;MACF,CArBD,EAqBGM,MArBH,CAqBU,UAAUC,MAAV,EAAkBC,MAAlB,EAA0B;QAClC,IAAInC,WAAJ,EAAiB;UACf,IAAIoC,eAAe,GAAGxC,OAAO,CAACyC,gBAAR,CAAyBF,MAAzB,CAAtB;UACA,IAAIG,cAAc,GAAGF,eAAe,GAAGA,eAAe,CAACf,QAAnB,GAA8B7F,UAAlE;UACA,IAAI4F,OAAO,GAAGZ,aAAa,CAAC0B,MAAD,EAASI,cAAT,CAA3B;UACAlB,OAAO,CAACC,QAAR,GAAmBiB,cAAnB;UACApK,OAAO,CAACqK,WAAR,CAAoBnB,OAApB,EAA6B;YAC3BC,QAAQ,EAAE,EAAE1I,SAAS,CAACwH,IAAI,CAAC/G,GAAL,CAASgH,QAAT,EAAmB8B,MAAnB,CAAD,EAA6B5B,WAA7B,EAA0CC,WAA1C,EAAuD,IAAvD,CAAT,GAAwE7G,IAAI,CAACW,EAAL,GAAU,CAApF;UADiB,CAA7B,EAEGpB,WAFH;UAGA8B,KAAK,CAACgC,GAAN,CAAUqE,OAAV;UACAjB,IAAI,CAAC4B,gBAAL,CAAsBG,MAAtB,EAA8Bd,OAA9B;QACD;;QAED,IAAIlB,YAAJ,EAAkB;UAChB,IAAIsC,gBAAgB,GAAG3C,eAAe,CAACsC,MAAD,CAAtC;UACA,IAAIM,gBAAgB,GAAGD,gBAAgB,GAAGA,gBAAgB,CAAC/F,KAAjB,CAAuBhB,QAA1B,GAAqCD,UAA5E;UACA,IAAImG,QAAQ,GAAGL,cAAc,CAACY,MAAD,EAASO,gBAAT,CAA7B;UACA,IAAIT,MAAM,GAAG/B,aAAa,CAAC7G,GAAd,CAAkB,MAAlB,CAAb;UACAlB,OAAO,CAACqK,WAAR,CAAoBZ,QAApB,EAA8B;YAC5BlF,KAAK,EAAE;cACLhB,QAAQ,EAAE9C,SAAS,CAACwH,IAAI,CAAC/G,GAAL,CAASgH,QAAT,EAAmB8B,MAAnB,CAAD,EAA6B5B,WAA7B,EAA0CC,WAA1C,EAAuDyB,MAAvD;YADd;UADqB,CAA9B,EAIG/I,WAJH;UAKA8B,KAAK,CAACgC,GAAN,CAAU4E,QAAV;UACA5B,YAAY,CAACmC,MAAD,CAAZ,GAAuBP,QAAvB;QACD;MACF,CA/CD,EA+CGe,OA/CH;MAgDAvC,IAAI,CAACwC,IAAL,CAAU,UAAUlC,GAAV,EAAe;QACvB,IAAIC,SAAS,GAAGP,IAAI,CAACQ,YAAL,CAAkBF,GAAlB,CAAhB;QACA,IAAImC,aAAa,GAAGlC,SAAS,CAAC/E,QAAV,CAAmB,UAAnB,CAApB;;QAEA,IAAIqE,WAAJ,EAAiB;UACf,IAAIoB,OAAO,GAAGjB,IAAI,CAACkC,gBAAL,CAAsB5B,GAAtB,CAAd;UACA,IAAIoC,WAAW,GAAG1C,IAAI,CAAC2C,aAAL,CAAmBrC,GAAnB,EAAwB,OAAxB,CAAlB;UACA,IAAIsC,WAAW,GAAGF,WAAW,CAAChG,IAA9B;;UAEA,IAAIuE,OAAO,YAAYtI,OAAvB,EAAgC;YAC9B,IAAIkK,SAAS,GAAG5B,OAAO,CAACpC,KAAxB;YACAoC,OAAO,CAAC6B,QAAR,CAAiBlK,MAAM,CAAC;cACtBmK,KAAK,EAAEF,SAAS,CAACE,KADK;cAEtB7D,CAAC,EAAE2D,SAAS,CAAC3D,CAFS;cAGtBC,CAAC,EAAE0D,SAAS,CAAC1D,CAHS;cAItBjG,KAAK,EAAE2J,SAAS,CAAC3J,KAJK;cAKtBE,MAAM,EAAEyJ,SAAS,CAACzJ;YALI,CAAD,EAMpBsJ,WANoB,CAAvB;UAOD,CATD,MASO;YACLzB,OAAO,CAAC6B,QAAR,CAAiBJ,WAAjB;YACAzB,OAAO,CAACzG,IAAR,KAAiB,SAAjB,IAA8ByG,OAAO,CAAC+B,QAAR,CAAiBJ,WAAjB,CAA9B;UACD;;UAED3B,OAAO,CAACxE,QAAR,CAAiB8D,SAAS,CAAC/E,QAAV,CAAmB,CAAC,SAAD,EAAY,WAAZ,CAAnB,EAA6CyH,YAA7C,EAAjB;;UAEA,IAAIhC,OAAO,CAACpC,KAAR,CAAcnC,IAAd,KAAuB,MAA3B,EAAmC;YACjCuE,OAAO,CAACxE,QAAR,CAAiB,MAAjB,EAAyBI,QAAQ,CAACrE,SAAS,CAACwH,IAAI,CAAC/G,GAAL,CAASgH,QAAT,EAAmBK,GAAnB,CAAD,EAA0BH,WAA1B,EAAuC,CAAC,CAAD,EAAI,CAAJ,CAAvC,EAA+C,IAA/C,CAAV,CAAjC;UACD;;UAEDc,OAAO,CAACiC,cAAR,GAAyB,CAAzB;UACAlL,wBAAwB,CAACiJ,OAAD,EAAUV,SAAV,CAAxB;UACAtI,mBAAmB,CAACgJ,OAAD,EAAUwB,aAAa,CAACxJ,GAAd,CAAkB,OAAlB,CAAV,EAAsCwJ,aAAa,CAACxJ,GAAd,CAAkB,WAAlB,CAAtC,CAAnB;QACD;;QAED,IAAI8G,YAAJ,EAAkB;UAChB,IAAIyB,QAAQ,GAAG5B,YAAY,CAACU,GAAD,CAA3B;UACAkB,QAAQ,CAACsB,QAAT,CAAkB9C,IAAI,CAAC2C,aAAL,CAAmBrC,GAAnB,EAAwB,OAAxB,CAAlB;UACAkB,QAAQ,CAAC/E,QAAT,CAAkB8D,SAAS,CAAC/E,QAAV,CAAmB,CAAC,UAAD,EAAa,WAAb,CAAnB,EAA8CyH,YAA9C,EAAlB;UACAzB,QAAQ,CAAC0B,cAAT,GAA0B,CAA1B;UACAlL,wBAAwB,CAACwJ,QAAD,EAAWjB,SAAX,CAAxB;UACAtI,mBAAmB,CAACuJ,QAAD,EAAWiB,aAAa,CAACxJ,GAAd,CAAkB,OAAlB,CAAX,EAAuCwJ,aAAa,CAACxJ,GAAd,CAAkB,WAAlB,CAAvC,CAAnB;QACD;MACF,CA1CD;MA2CA,KAAK0G,YAAL,GAAoBC,YAApB;IACD;EACF,CAnKD;;EAqKAzF,SAAS,CAACM,SAAV,CAAoBwC,aAApB,GAAoC,UAAUnE,WAAV,EAAuBiC,OAAvB,EAAgC;IAClE,IAAIoI,WAAW,GAAGrK,WAAW,CAAC0C,QAAZ,CAAqB,QAArB,CAAlB;IACA,IAAI4H,UAAU,GAAGD,WAAW,CAAClK,GAAZ,CAAgB,MAAhB,CAAjB;;IAEA,IAAImK,UAAJ,EAAgB;MACd,IAAIC,UAAU,GAAGF,WAAW,CAAClK,GAAZ,CAAgB,MAAhB,CAAjB;MACA,IAAIqK,UAAU,GAAGH,WAAW,CAAClK,GAAZ,CAAgB,MAAhB,CAAjB;MACA,IAAIsK,YAAY,GAAGJ,WAAW,CAAClK,GAAZ,CAAgB,cAAhB,CAAnB;MACA,IAAIuK,gBAAgB,GAAGL,WAAW,CAAClK,GAAZ,CAAgB,YAAhB,CAAvB;MACA,IAAIwK,MAAM,GAAG/K,YAAY,CAAC4K,UAAD,EAAavI,OAAO,CAACtB,EAAR,GAAa4J,UAAU,GAAG,CAA1B,GAA8B/K,YAAY,CAACiL,YAAY,CAAC,CAAD,CAAb,EAAkBxI,OAAO,CAACpB,CAA1B,CAAvD,EAAqFoB,OAAO,CAACrB,EAAR,GAAa2J,UAAU,GAAG,CAA1B,GAA8B/K,YAAY,CAACiL,YAAY,CAAC,CAAD,CAAb,EAAkBxI,OAAO,CAACpB,CAA1B,CAA/H,EAA6J0J,UAA7J,EAAyKA,UAAzK,EAAqL,IAArL,EAA2LG,gBAA3L,CAAzB;MACAC,MAAM,CAAChC,EAAP,GAAY0B,WAAW,CAAClK,GAAZ,CAAgB,WAAhB,IAA+B,CAA/B,GAAmC,CAA/C;MACAwK,MAAM,CAAChH,QAAP,CAAgB0G,WAAW,CAAC3H,QAAZ,CAAqB,WAArB,EAAkCyH,YAAlC,EAAhB;MACA,KAAKrI,KAAL,CAAWgC,GAAX,CAAe6G,MAAf;IACD;EACF,CAdD;;EAgBAtJ,SAAS,CAACM,SAAV,CAAoBuC,qBAApB,GAA4C,UAAUlE,WAAV,EAAuB6B,OAAvB,EAAgC5B,GAAhC,EAAqC8D,QAArC,EAA+C9B,OAA/C,EAAwD;IAClG,IAAIV,KAAK,GAAG,IAAZ;;IAEA,IAAI2F,IAAI,GAAGlH,WAAW,CAACoC,OAAZ,EAAX;IACA,IAAI+E,QAAQ,GAAGD,IAAI,CAACE,YAAL,CAAkB,OAAlB,CAAf;IACA,IAAI/C,MAAM,GAAG,CAACrE,WAAW,CAACG,GAAZ,CAAgB,KAAhB,CAAd;IACA,IAAImE,MAAM,GAAG,CAACtE,WAAW,CAACG,GAAZ,CAAgB,KAAhB,CAAd;IACA,IAAIyK,YAAY,GAAG,IAAI3L,OAAO,CAAC4L,KAAZ,EAAnB;IACA,IAAIC,WAAW,GAAG,EAAlB;IACA,IAAIC,YAAY,GAAG,EAAnB;IACA,IAAIC,YAAY,GAAGhL,WAAW,CAACiL,kBAAZ,EAAnB;IACA/D,IAAI,CAAC0B,IAAL,CAAU,KAAKzG,KAAf,EAAsB2B,GAAtB,CAA0B,UAAU0D,GAAV,EAAe;MACvCsD,WAAW,CAACtD,GAAD,CAAX,GAAmB,IAAIvI,OAAO,CAACiH,IAAZ,CAAiB;QAClCxC,MAAM,EAAE;MAD0B,CAAjB,CAAnB;MAGAqH,YAAY,CAACvD,GAAD,CAAZ,GAAoB,IAAIvI,OAAO,CAACiH,IAAZ,CAAiB;QACnCxC,MAAM,EAAE;MAD2B,CAAjB,CAApB;IAGD,CAPD,EAOGsF,MAPH,CAOU,UAAUxB,GAAV,EAAe0B,MAAf,EAAuB;MAC/B4B,WAAW,CAACtD,GAAD,CAAX,GAAmBjG,KAAK,CAAC2J,SAAN,CAAgBhC,MAAhB,CAAnB;MACA6B,YAAY,CAACvD,GAAD,CAAZ,GAAoBjG,KAAK,CAAC4J,UAAN,CAAiBjC,MAAjB,CAApB;IACD,CAVD,EAUGO,OAVH;IAWAvC,IAAI,CAACwC,IAAL,CAAU,UAAUlC,GAAV,EAAe;MACvB,IAAIC,SAAS,GAAGP,IAAI,CAACQ,YAAL,CAAkBF,GAAlB,CAAhB;MACA,IAAIzG,KAAK,GAAGmG,IAAI,CAAC/G,GAAL,CAASgH,QAAT,EAAmBK,GAAnB,CAAZ;MACA,IAAI4D,SAAS,GAAG,IAAInM,OAAO,CAAC4L,KAAZ,EAAhB;MACA,IAAI5E,SAAS,GAAGlC,QAAQ,CAACrE,SAAS,CAACqB,KAAD,EAAQ,CAACsD,MAAD,EAASC,MAAT,CAAR,EAA0B,CAAC,CAAD,EAAI,CAAJ,CAA1B,EAAkC,IAAlC,CAAV,CAAxB;MACA,IAAI+G,cAAc,GAAG5D,SAAS,CAAC/E,QAAV,CAAmB,OAAnB,CAArB;;MAEA,IAAI2I,cAAc,CAAClL,GAAf,CAAmB,MAAnB,CAAJ,EAAgC;QAC9B,IAAImL,iBAAiB,GAAGD,cAAc,CAAClL,GAAf,CAAmB,cAAnB,CAAxB;QACA,IAAIoL,MAAM,GAAGtJ,OAAO,CAACtB,EAAR,GAAanB,YAAY,CAAC8L,iBAAiB,CAAC,CAAD,CAAlB,EAAuBrJ,OAAO,CAACpB,CAA/B,CAAtC;QACA,IAAI2K,MAAM,GAAGvJ,OAAO,CAACrB,EAAR,GAAapB,YAAY,CAAC8L,iBAAiB,CAAC,CAAD,CAAlB,EAAuBrJ,OAAO,CAACpB,CAA/B,CAAtC;QACA,IAAI4K,OAAO,GAAGX,WAAW,CAACtD,GAAD,CAAzB;QACAiE,OAAO,CAACC,IAAR,CAAa;UACX3F,KAAK,EAAE3G,eAAe,CAACiM,cAAD,EAAiB;YACrCjF,CAAC,EAAEmF,MADkC;YAErClF,CAAC,EAAEmF,MAFkC;YAGrCrF,IAAI,EAAEe,IAAI,CAACyE,OAAL,CAAanE,GAAb,CAH+B;YAIrCjB,KAAK,EAAE,QAJ8B;YAKrCD,aAAa,EAAE;UALsB,CAAjB,EAMnB;YACDE,YAAY,EAAEP;UADb,CANmB;QADX,CAAb;QAWAmF,SAAS,CAACtH,GAAV,CAAc2H,OAAd;MACD;;MAED,IAAIG,eAAe,GAAGnE,SAAS,CAAC/E,QAAV,CAAmB,QAAnB,CAAtB;;MAEA,IAAIkJ,eAAe,CAACzL,GAAhB,CAAoB,MAApB,CAAJ,EAAiC;QAC/B,IAAI0L,kBAAkB,GAAGD,eAAe,CAACzL,GAAhB,CAAoB,cAApB,CAAzB;QACA,IAAI2L,OAAO,GAAG7J,OAAO,CAACtB,EAAR,GAAanB,YAAY,CAACqM,kBAAkB,CAAC,CAAD,CAAnB,EAAwB5J,OAAO,CAACpB,CAAhC,CAAvC;QACA,IAAIkL,OAAO,GAAG9J,OAAO,CAACrB,EAAR,GAAapB,YAAY,CAACqM,kBAAkB,CAAC,CAAD,CAAnB,EAAwB5J,OAAO,CAACpB,CAAhC,CAAvC;QACA,IAAIT,KAAK,GAAGZ,YAAY,CAACoM,eAAe,CAACzL,GAAhB,CAAoB,OAApB,CAAD,EAA+B8B,OAAO,CAACpB,CAAvC,CAAxB;QACA,IAAIP,MAAM,GAAGd,YAAY,CAACoM,eAAe,CAACzL,GAAhB,CAAoB,QAApB,CAAD,EAAgC8B,OAAO,CAACpB,CAAxC,CAAzB;QACA,IAAImL,WAAW,GAAGhM,WAAW,CAACG,GAAZ,CAAgB,CAAC,UAAD,EAAa,MAAb,CAAhB,IAAwC+G,IAAI,CAAC2C,aAAL,CAAmBrC,GAAnB,EAAwB,OAAxB,EAAiC5D,IAAzE,GAAgFqC,SAAlG;QACA,IAAIwF,OAAO,GAAGV,YAAY,CAACvD,GAAD,CAA1B;QACA,IAAIyE,WAAW,GAAGL,eAAe,CAACzL,GAAhB,CAAoB,WAApB,CAAlB;QACAsL,OAAO,CAACC,IAAR,CAAa;UACX3F,KAAK,EAAE3G,eAAe,CAACwM,eAAD,EAAkB;YACtCxF,CAAC,EAAE0F,OADmC;YAEtCzF,CAAC,EAAE0F,OAFmC;YAGtC5F,IAAI,EAAErF,WAAW,CAACC,KAAD,EAAQkL,WAAR,CAHqB;YAItC7L,KAAK,EAAE8L,KAAK,CAAC9L,KAAD,CAAL,GAAe,IAAf,GAAsBA,KAJS;YAKtCE,MAAM,EAAE4L,KAAK,CAAC5L,MAAD,CAAL,GAAgB,IAAhB,GAAuBA,MALO;YAMtCiG,KAAK,EAAE,QAN+B;YAOtCD,aAAa,EAAE;UAPuB,CAAlB,EAQnB;YACDE,YAAY,EAAEwF;UADb,CARmB;QADX,CAAb;QAaA3M,sBAAsB,CAACoM,OAAD,EAAU;UAC9BU,MAAM,EAAEP;QADsB,CAAV,EAEnB7K,KAFmB,EAEZ,UAAUA,KAAV,EAAiB;UACzB,OAAOD,WAAW,CAACC,KAAD,EAAQkL,WAAR,CAAlB;QACD,CAJqB,CAAtB;QAKAjB,YAAY,IAAI1L,iBAAiB,CAACmM,OAAD,EAAUjE,GAAV,EAAeN,IAAf,EAAqBlH,WAArB,EAAkC;UACjEoM,iBAAiB,EAAE,UAAUC,cAAV,EAA0BC,MAA1B,EAAkCC,QAAlC,EAA4CC,aAA5C,EAA2DC,GAA3D,EAAgEC,YAAhE,EAA8E;YAC/F,OAAO5L,WAAW,CAAC4L,YAAY,GAAGA,YAAY,CAACC,iBAAhB,GAAoC5L,KAAjD,EAAwDkL,WAAxD,CAAlB;UACD;QAHgE,CAAlC,CAAjC;QAKAb,SAAS,CAACtH,GAAV,CAAc2H,OAAd;MACD;;MAEDb,YAAY,CAAC9G,GAAb,CAAiBsH,SAAjB;IACD,CAhED;IAiEA,KAAKtJ,KAAL,CAAWgC,GAAX,CAAe8G,YAAf;IACA,KAAKM,SAAL,GAAiBJ,WAAjB;IACA,KAAKK,UAAL,GAAkBJ,YAAlB;EACD,CA1FD;;EA4FA1J,SAAS,CAACK,IAAV,GAAiB,OAAjB;EACA,OAAOL,SAAP;AACD,CA1dD,CA0dE9B,SA1dF,CAFA;;AA8dA,eAAe8B,SAAf"},"metadata":{},"sourceType":"module"}